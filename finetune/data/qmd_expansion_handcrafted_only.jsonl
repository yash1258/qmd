{"output": [["lex", "ssh key auth setup"], ["lex", "ssh public private key pair"], ["lex", "passwordless ssh login"]], "query": "ssh key authentication only: lex"}
{"output": [["vec", "how to set up ssh key-based authentication instead of passwords"], ["vec", "step-by-step guide to generating and configuring ssh keys for secure server access"]], "query": "ssh key authentication only: vec"}
{"output": [["hyde", "Generate an SSH key pair with ssh-keygen -t ed25519. Copy the public key to ~/.ssh/authorized_keys on the remote server using ssh-copy-id. Ensure permissions are 700 for .ssh and 600 for authorized_keys."]], "query": "ssh key authentication only: hyde"}
{"output": [["lex", "python venv virtualenv"], ["lex", "pip virtual environment setup"], ["lex", "python isolated dependencies"]], "query": "Python virtual environments only: lex"}
{"output": [["vec", "how to create and activate a python virtual environment for project isolation"], ["vec", "what is the difference between venv, virtualenv, and conda for managing python dependencies"]], "query": "Python virtual environments only: vec"}
{"output": [["hyde", "Create a virtual environment with python -m venv myenv, then activate it with source myenv/bin/activate on Unix or myenv\\Scripts\\activate on Windows. Install packages with pip and they stay isolated from your system Python."]], "query": "Python virtual environments only: hyde"}
{"output": [["lex", "git merge conflict resolve"], ["lex", "git conflict markers HEAD"], ["lex", "resolving merge conflicts"]], "query": "git merge conflicts only: lex"}
{"output": [["vec", "how to resolve merge conflicts in git when two branches modify the same lines"], ["vec", "what do the conflict markers mean and how do you manually edit conflicted files"]], "query": "git merge conflicts only: vec"}
{"output": [["hyde", "Git marks conflicts with <<<<<<< HEAD, =======, and >>>>>>> branch-name. Edit the file to keep the code you want, remove the markers, then git add the file and commit. Use git mergetool for a visual diff interface."]], "query": "git merge conflicts only: hyde"}
{"output": [["lex", "tcp udp protocol difference"], ["lex", "tcp reliable udp fast"], ["lex", "connection-oriented vs connectionless"]], "query": "TCP vs UDP only: lex"}
{"output": [["vec", "what are the key differences between TCP and UDP network protocols"], ["vec", "when should you use TCP versus UDP for application networking"]], "query": "TCP vs UDP only: vec"}
{"output": [["hyde", "TCP provides reliable, ordered delivery with acknowledgments and retransmission. UDP is faster but unreliable—packets may arrive out of order or not at all. Use TCP for web, email, file transfer. Use UDP for video streaming, gaming, DNS where speed matters more than reliability."]], "query": "TCP vs UDP only: hyde"}
{"output": [["lex", "docker compose volume mount"], ["lex", "docker persistent storage volumes"], ["lex", "compose yaml volumes section"]], "query": "Docker compose volumes only: lex"}
{"output": [["vec", "how to configure persistent volumes in docker compose for data that survives container restarts"], ["vec", "what is the difference between bind mounts and named volumes in docker compose"]], "query": "Docker compose volumes only: vec"}
{"output": [["hyde", "In docker-compose.yml, define volumes under the top-level volumes key and reference them in services. Named volumes persist data in Docker's storage. Bind mounts map host directories directly: volumes: - ./data:/app/data for development, - myvolume:/app/data for production."]], "query": "Docker compose volumes only: hyde"}
{"output": [["lex", "regex lookahead assertion"], ["lex", "regex lookbehind positive negative"], ["lex", "zero-width assertions regex"]], "query": "regex lookahead lookbehind only: lex"}
{"output": [["vec", "how do lookahead and lookbehind assertions work in regular expressions"], ["vec", "what is the syntax for positive and negative lookahead and lookbehind in regex"]], "query": "regex lookahead lookbehind only: vec"}
{"output": [["hyde", "Lookahead (?=pattern) matches a position followed by pattern without consuming it. Negative lookahead (?!pattern) matches where pattern doesn't follow. Lookbehind (?<=pattern) matches a position preceded by pattern. Example: \\d+(?= dollars) matches numbers followed by 'dollars'."]], "query": "regex lookahead lookbehind only: hyde"}
{"output": [["lex", "kubernetes secrets k8s"], ["lex", "k8s secret yaml base64"], ["lex", "kubectl create secret"]], "query": "Kubernetes secrets management only: lex"}
{"output": [["vec", "how to create and use secrets in kubernetes for sensitive configuration data"], ["vec", "what are best practices for managing secrets in kubernetes clusters"]], "query": "Kubernetes secrets management only: vec"}
{"output": [["hyde", "Create secrets with kubectl create secret generic mysecret --from-literal=password=abc123. Reference in pods via env valueFrom secretKeyRef or volume mounts. Secrets are base64 encoded, not encrypted—use sealed-secrets or external secret managers like Vault for production."]], "query": "Kubernetes secrets management only: hyde"}
{"output": [["lex", "cors error fix browser"], ["lex", "access-control-allow-origin header"], ["lex", "cors preflight request"]], "query": "CORS errors fix only: lex"}
{"output": [["vec", "how to fix CORS errors when making API requests from a web browser"], ["vec", "what causes cross-origin resource sharing errors and how do you configure the server to allow them"]], "query": "CORS errors fix only: vec"}
{"output": [["hyde", "CORS errors occur when a browser blocks requests to a different origin. Fix by adding Access-Control-Allow-Origin headers on the server. For Express: app.use(cors()). For preflight requests, handle OPTIONS and return Access-Control-Allow-Methods and Access-Control-Allow-Headers."]], "query": "CORS errors fix only: hyde"}
{"output": [["lex", "postgresql index explain analyze"], ["lex", "postgres btree index performance"], ["lex", "create index postgresql"]], "query": "PostgreSQL indexes explain only: lex"}
{"output": [["vec", "how to use EXPLAIN ANALYZE to understand query performance and index usage in postgresql"], ["vec", "what types of indexes does postgresql support and when should you use each"]], "query": "PostgreSQL indexes explain only: vec"}
{"output": [["hyde", "Run EXPLAIN ANALYZE SELECT... to see the query plan and actual execution time. Look for Seq Scan on large tables—add an index with CREATE INDEX idx_name ON table(column). B-tree indexes work for equality and range queries, GIN for full-text search and arrays, GiST for geometric data."]], "query": "PostgreSQL indexes explain only: hyde"}
{"output": [["lex", "jwt refresh token flow"], ["lex", "access token refresh token"], ["lex", "jwt token expiration renewal"]], "query": "JWT token refresh only: lex"}
{"output": [["vec", "how does the jwt refresh token flow work for maintaining user sessions"], ["vec", "what is the difference between access tokens and refresh tokens in jwt authentication"]], "query": "JWT token refresh only: vec"}
{"output": [["hyde", "Access tokens are short-lived (15 min) and sent with each request. Refresh tokens are long-lived (days/weeks) and stored securely. When the access token expires, send the refresh token to /auth/refresh to get a new access token without re-authenticating."]], "query": "JWT token refresh only: hyde"}
{"output": [["lex", "react useeffect cleanup function"], ["lex", "useeffect return cleanup"], ["lex", "react unmount cleanup"]], "query": "React useEffect cleanup only: lex"}
{"output": [["vec", "how to properly clean up side effects in react useeffect to prevent memory leaks"], ["vec", "when does the useeffect cleanup function run and what should you clean up"]], "query": "React useEffect cleanup only: vec"}
{"output": [["hyde", "Return a cleanup function from useEffect to run before the component unmounts or before the effect re-runs. Use it to cancel subscriptions, clear timers, and abort fetch requests. Example: useEffect(() => { const id = setInterval(fn, 1000); return () => clearInterval(id); }, []);"]], "query": "React useEffect cleanup only: hyde"}
{"output": [["lex", "nginx reverse proxy config"], ["lex", "nginx proxy_pass upstream"], ["lex", "nginx load balancer setup"]], "query": "nginx reverse proxy only: lex"}
{"output": [["vec", "how to configure nginx as a reverse proxy to forward requests to backend servers"], ["vec", "what nginx directives do you need for a basic reverse proxy configuration"]], "query": "nginx reverse proxy only: vec"}
{"output": [["hyde", "In nginx.conf, use proxy_pass inside a location block: location /api { proxy_pass http://localhost:3000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; }. Add upstream blocks for load balancing across multiple backend servers."]], "query": "nginx reverse proxy only: hyde"}
{"output": [["lex", "systemd service unit file"], ["lex", "systemctl enable start service"], ["lex", "systemd service configuration"]], "query": "systemd service file only: lex"}
{"output": [["vec", "how to create a systemd service file to run an application as a linux daemon"], ["vec", "what are the essential sections and directives in a systemd unit file"]], "query": "systemd service file only: vec"}
{"output": [["hyde", "Create /etc/systemd/system/myapp.service with [Unit] Description, [Service] ExecStart=/path/to/app, Restart=always, User=appuser, and [Install] WantedBy=multi-user.target. Run systemctl daemon-reload, then systemctl enable --now myapp."]], "query": "systemd service file only: hyde"}
{"output": [["lex", "websocket http difference"], ["lex", "websocket persistent connection"], ["lex", "http polling vs websocket"]], "query": "websocket vs http only: lex"}
{"output": [["vec", "what are the differences between websockets and http for real-time communication"], ["vec", "when should you use websockets instead of http long polling or server-sent events"]], "query": "websocket vs http only: vec"}
{"output": [["hyde", "HTTP is request-response: client asks, server answers, connection closes. WebSocket upgrades HTTP to a persistent bidirectional connection. Use WebSocket for chat, live updates, gaming. Use SSE for server-to-client only streaming. HTTP polling wastes bandwidth with repeated requests."]], "query": "websocket vs http only: hyde"}
{"output": [["lex", "sql injection prevent parameterized"], ["lex", "prepared statements sql injection"], ["lex", "sql injection sanitize input"]], "query": "SQL injection prevention only: lex"}
{"output": [["vec", "how to prevent sql injection attacks in web applications"], ["vec", "why are parameterized queries and prepared statements important for database security"]], "query": "SQL injection prevention only: vec"}
{"output": [["hyde", "Never concatenate user input into SQL strings. Use parameterized queries: cursor.execute('SELECT * FROM users WHERE id = ?', (user_id,)). ORMs like SQLAlchemy handle this automatically. Validate and sanitize input, but parameterization is the primary defense."]], "query": "SQL injection prevention only: hyde"}
{"output": [["lex", "typescript generics type parameter"], ["lex", "typescript generic function interface"], ["lex", "ts generics constraints extends"]], "query": "TypeScript generics only: lex"}
{"output": [["vec", "how to use generics in typescript to write reusable type-safe functions and classes"], ["vec", "what is the syntax for generic type parameters and constraints in typescript"]], "query": "TypeScript generics only: vec"}
{"output": [["hyde", "Generics let you write flexible, reusable code while maintaining type safety. Declare with angle brackets: function identity<T>(arg: T): T { return arg; }. Add constraints with extends: function getLength<T extends { length: number }>(item: T): number { return item.length; }."]], "query": "TypeScript generics only: hyde"}
{"output": [["lex", "oauth2 authorization code flow"], ["lex", "oauth authorization code grant"], ["lex", "oauth2 pkce code verifier"]], "query": "OAuth 2.0 authorization code flow only: lex"}
{"output": [["vec", "how does the oauth 2.0 authorization code flow work for secure third-party authentication"], ["vec", "what are the steps in the oauth authorization code grant and why is pkce recommended"]], "query": "OAuth 2.0 authorization code flow only: vec"}
{"output": [["hyde", "User clicks login, redirected to auth server with client_id and redirect_uri. User authenticates, gets authorization code. App exchanges code for tokens at token endpoint. PKCE adds code_verifier/code_challenge to prevent interception attacks—required for public clients."]], "query": "OAuth 2.0 authorization code flow only: hyde"}
{"output": [["lex", "redis cache strategy pattern"], ["lex", "redis cache aside through"], ["lex", "redis ttl expiration caching"]], "query": "Redis caching strategies only: lex"}
{"output": [["vec", "what are the common caching strategies when using redis for application performance"], ["vec", "how do you implement cache-aside, write-through, and write-behind patterns with redis"]], "query": "Redis caching strategies only: vec"}
{"output": [["hyde", "Cache-aside: app checks Redis first, fetches from DB on miss, writes to cache. Write-through: writes go to cache and DB together. Write-behind: writes to cache, async sync to DB. Set TTL with EXPIRE to prevent stale data. Use SETEX for atomic set-with-expiry."]], "query": "Redis caching strategies only: hyde"}
{"output": [["lex", "graphql rest api comparison"], ["lex", "graphql query flexibility"], ["lex", "rest vs graphql tradeoffs"]], "query": "GraphQL vs REST only: lex"}
{"output": [["vec", "what are the main differences between graphql and rest api design approaches"], ["vec", "when should you choose graphql over rest for your api architecture"]], "query": "GraphQL vs REST only: vec"}
{"output": [["hyde", "REST uses fixed endpoints returning predefined data shapes. GraphQL uses one endpoint where clients specify exactly what fields they need, reducing over-fetching. REST is simpler, better cached. GraphQL excels for mobile apps, complex data requirements, and avoiding multiple round trips."]], "query": "GraphQL vs REST only: hyde"}
{"output": [["lex", "linux chmod file permissions"], ["lex", "unix rwx permission bits"], ["lex", "chmod 755 644 meaning"]], "query": "linux file permissions chmod only: lex"}
{"output": [["vec", "how do linux file permissions work and how do you change them with chmod"], ["vec", "what do the rwx permission bits mean for owner, group, and others"]], "query": "linux file permissions chmod only: vec"}
{"output": [["hyde", "Permissions are rwx for read, write, execute. Three groups: owner, group, others. chmod 755 means rwxr-xr-x (owner full, others read+execute). chmod 644 means rw-r--r-- (owner read+write, others read only). Use chmod +x to add execute permission."]], "query": "linux file permissions chmod only: hyde"}
{"output": [["lex", "async await try catch"], ["lex", "javascript promise error handling"], ["lex", "async function exception handling"]], "query": "async await error handling only: lex"}
{"output": [["vec", "how to properly handle errors in javascript async await functions"], ["vec", "what happens when an async function throws and how do you catch those errors"]], "query": "async await error handling only: vec"}
{"output": [["hyde", "Wrap await calls in try-catch blocks: try { const data = await fetchData(); } catch (err) { console.error(err); }. Unhandled rejections in async functions become unhandled promise rejections. For multiple awaits, catch individually or use Promise.allSettled to handle partial failures."]], "query": "async await error handling only: hyde"}
{"output": [["lex", "elasticsearch query dsl"], ["lex", "elasticsearch bool must should"], ["lex", "es full text search query"]], "query": "Elasticsearch query DSL only: lex"}
{"output": [["vec", "how to write search queries using elasticsearch query dsl syntax"], ["vec", "what are the common query types in elasticsearch like match, term, and bool queries"]], "query": "Elasticsearch query DSL only: vec"}
{"output": [["hyde", "Elasticsearch Query DSL uses JSON. Match query for full-text: {match: {title: 'search'}}. Term for exact: {term: {status: 'published'}}. Bool combines queries: {bool: {must: [...], should: [...], filter: [...], must_not: [...]}}. Filter context skips scoring for faster filtering."]], "query": "Elasticsearch query DSL only: hyde"}
{"output": [["lex", "terraform state file backend"], ["lex", "terraform remote state s3"], ["lex", "tfstate locking management"]], "query": "terraform state management only: lex"}
{"output": [["vec", "how to manage terraform state files and what are the best practices for team collaboration"], ["vec", "why should you use remote state backends in terraform and how do you configure them"]], "query": "terraform state management only: vec"}
{"output": [["hyde", "Store state remotely in S3, GCS, or Terraform Cloud—never commit tfstate to git. Configure backend in terraform { backend \"s3\" { bucket = \"my-state\", key = \"prod.tfstate\", region = \"us-east-1\", dynamodb_table = \"tf-locks\" } }. DynamoDB provides state locking to prevent concurrent modifications."]], "query": "terraform state management only: hyde"}
{"output": [["lex", "monorepo polyrepo comparison"], ["lex", "monorepo benefits drawbacks"], ["lex", "single repo multiple repos"]], "query": "monorepo vs polyrepo only: lex"}
{"output": [["vec", "what are the tradeoffs between using a monorepo versus multiple repositories"], ["vec", "when does a monorepo make sense and what tools help manage large monorepos"]], "query": "monorepo vs polyrepo only: vec"}
{"output": [["hyde", "Monorepos keep all code in one repository—easier atomic changes across packages, shared tooling, consistent versioning. Polyrepos give teams autonomy, simpler CI, clearer ownership. Use monorepos for tightly coupled code. Tools: Nx, Turborepo, Lerna, Bazel for build orchestration."]], "query": "monorepo vs polyrepo only: hyde"}
{"output": [["lex", "prometheus alerting rules config"], ["lex", "prometheus alertmanager rules"], ["lex", "promql alert expressions"]], "query": "prometheus alerting rules only: lex"}
{"output": [["vec", "how to write prometheus alerting rules to notify on metric thresholds"], ["vec", "what is the syntax for prometheus alert rules and how do they integrate with alertmanager"]], "query": "prometheus alerting rules only: vec"}
{"output": [["hyde", "Define rules in YAML: groups: - name: example rules: - alert: HighErrorRate expr: rate(http_errors_total[5m]) > 0.1 for: 5m labels: severity: critical annotations: summary: High error rate. Prometheus evaluates rules periodically and sends firing alerts to Alertmanager for routing and deduplication."]], "query": "prometheus alerting rules only: hyde"}
{"output": [["lex", "css flexbox center align"], ["lex", "flexbox justify-content align-items"], ["lex", "css center div flexbox"]], "query": "CSS flexbox centering only: lex"}
{"output": [["vec", "how to center elements horizontally and vertically using css flexbox"], ["vec", "what flexbox properties do you use to center content in a container"]], "query": "CSS flexbox centering only: vec"}
{"output": [["hyde", "On the container, set display: flex; justify-content: center; align-items: center;. justify-content handles the main axis (horizontal by default), align-items handles the cross axis. Add height: 100vh to center within the viewport. For a single item, margin: auto also works inside flex containers."]], "query": "CSS flexbox centering only: hyde"}
{"output": [["lex", "database connection pool"], ["lex", "connection pooling performance"], ["lex", "db pool size configuration"]], "query": "database connection pooling only: lex"}
{"output": [["vec", "what is database connection pooling and why does it improve application performance"], ["vec", "how do you configure connection pool size for optimal database throughput"]], "query": "database connection pooling only: vec"}
{"output": [["hyde", "Opening database connections is expensive. Connection pools maintain reusable connections. Set pool size based on: pool_size = (core_count * 2) + effective_spindle_count. Too small starves the app, too large overwhelms the database. Popular libraries: HikariCP for Java, pgbouncer for PostgreSQL."]], "query": "database connection pooling only: hyde"}
{"output": [["lex", "kafka consumer group offset"], ["lex", "kafka partition consumer rebalance"], ["lex", "kafka consumer group id"]], "query": "kafka consumer groups only: lex"}
{"output": [["vec", "how do kafka consumer groups work for parallel message processing"], ["vec", "what happens during consumer group rebalancing and how are partitions assigned"]], "query": "kafka consumer groups only: vec"}
{"output": [["hyde", "Consumers with the same group.id share partitions—each partition is consumed by only one consumer in the group. Adding consumers triggers rebalancing. If consumers > partitions, some idle. Offsets track progress per partition. Use enable.auto.commit=false for exactly-once semantics with manual commits."]], "query": "kafka consumer groups only: hyde"}
{"output": [["lex", "vim search replace substitute"], ["lex", "vim sed command :%s"], ["lex", "vim find replace regex"]], "query": "vim search replace only: lex"}
{"output": [["vec", "how to search and replace text in vim using the substitute command"], ["vec", "what is the syntax for vim search and replace with regular expressions and flags"]], "query": "vim search replace only: vec"}
{"output": [["hyde", "Use :%s/old/new/g to replace all occurrences in the file. % means all lines, g means global (all matches per line). Add c for confirmation: :%s/old/new/gc. Use \\< and \\> for word boundaries. & in replacement refers to the matched text. Use :s for current line only."]], "query": "vim search replace only: hyde"}
{"output": [["lex", "http status codes list"], ["lex", "http 200 400 500 codes"], ["lex", "rest api status codes"]], "query": "http status codes meaning only: lex"}
{"output": [["vec", "what do the common http status codes mean and when should you use each"], ["vec", "how do you choose the right http status code for api responses"]], "query": "http status codes meaning only: vec"}
{"output": [["hyde", "200 OK success, 201 Created for POST, 204 No Content for DELETE. 400 Bad Request for invalid input, 401 Unauthorized for auth required, 403 Forbidden for insufficient permissions, 404 Not Found. 500 Internal Server Error for unexpected failures, 503 Service Unavailable for temporary issues."]], "query": "http status codes meaning only: hyde"}
{"output": [["lex", "binary search algorithm"], ["lex", "binary search sorted array"], ["lex", "binary search time complexity"]], "query": "binary search algorithm only: lex"}
{"output": [["vec", "how does the binary search algorithm work and what is its time complexity"], ["vec", "how do you implement binary search to find an element in a sorted array"]], "query": "binary search algorithm only: vec"}
{"output": [["hyde", "Binary search halves the search space each iteration. Compare target with middle element: if smaller, search left half; if larger, search right. O(log n) time complexity. Requires sorted input. Watch for integer overflow in mid calculation: use low + (high - low) / 2 instead of (low + high) / 2."]], "query": "binary search algorithm only: hyde"}
{"output": [["lex", "git rebase interactive squash"], ["lex", "git rebase -i edit commits"], ["lex", "git squash commits rebase"]], "query": "git rebase interactive only: lex"}
{"output": [["vec", "how to use git interactive rebase to edit, squash, and reorder commits"], ["vec", "what are the commands available in git rebase interactive mode"]], "query": "git rebase interactive only: vec"}
{"output": [["hyde", "Run git rebase -i HEAD~5 to edit the last 5 commits. In the editor, change 'pick' to: squash (s) to combine with previous, reword (r) to edit message, edit (e) to amend, drop (d) to remove. Save and follow prompts. Never rebase commits already pushed to shared branches."]], "query": "git rebase interactive only: hyde"}
{"output": [["lex", "docker environment variables"], ["lex", "docker env file compose"], ["lex", "docker run -e env vars"]], "query": "environment variables docker only: lex"}
{"output": [["vec", "how to pass environment variables to docker containers"], ["vec", "what are the different ways to set environment variables in docker and docker compose"]], "query": "environment variables docker only: vec"}
{"output": [["hyde", "Use -e flag: docker run -e DB_HOST=localhost myapp. In docker-compose.yml: environment: - DB_HOST=localhost or env_file: - .env. For secrets, prefer docker secrets or mount files. Variables in Dockerfile with ENV persist in the image; runtime -e overrides them."]], "query": "environment variables docker only: hyde"}
{"output": [["lex", "rate limiting algorithm api"], ["lex", "token bucket leaky bucket"], ["lex", "rate limit sliding window"]], "query": "rate limiting algorithms only: lex"}
{"output": [["vec", "what algorithms are used for api rate limiting and how do they differ"], ["vec", "how do token bucket and sliding window rate limiting algorithms work"]], "query": "rate limiting algorithms only: vec"}
{"output": [["hyde", "Token bucket: bucket fills at fixed rate, requests consume tokens, rejected when empty—allows bursts. Leaky bucket: requests queue, processed at fixed rate—smooths traffic. Sliding window: count requests in rolling time window. Fixed window has boundary issues; sliding window log is precise but memory-heavy."]], "query": "rate limiting algorithms only: hyde"}
{"output": [["lex", "blue green deployment strategy"], ["lex", "zero downtime deployment"], ["lex", "blue green kubernetes rollout"]], "query": "blue green deployment only: lex"}
{"output": [["vec", "what is blue green deployment and how does it enable zero downtime releases"], ["vec", "how do you implement blue green deployments in kubernetes or cloud environments"]], "query": "blue green deployment only: vec"}
{"output": [["hyde", "Blue-green runs two identical environments. Blue is live, green has the new version. Test green thoroughly, then switch the load balancer. Instant rollback by switching back to blue. In Kubernetes, use two deployments with a service selector update, or Argo Rollouts for automated blue-green."]], "query": "blue green deployment only: hyde"}
{"output": [["lex", "memory leak debug profiler"], ["lex", "memory leak detection tools"], ["lex", "heap dump memory analysis"]], "query": "memory leak debugging only: lex"}
{"output": [["vec", "how to find and fix memory leaks in applications"], ["vec", "what tools and techniques help identify memory leaks in different programming languages"]], "query": "memory leak debugging only: vec"}
{"output": [["hyde", "Use heap profilers: Chrome DevTools for JavaScript, VisualVM or MAT for Java, Valgrind for C/C++, tracemalloc for Python. Take heap snapshots before and after operations, compare retained objects. Common causes: forgotten event listeners, closures holding references, unbounded caches, circular references."]], "query": "memory leak debugging only: hyde"}
{"output": [["lex", "stripe webhook signature verify"], ["lex", "stripe webhook endpoint secret"], ["lex", "stripe event verification"]], "query": "Stripe webhook verification only: lex"}
{"output": [["vec", "how to verify stripe webhook signatures to ensure events are authentic"], ["vec", "what is the correct way to handle and validate incoming stripe webhook events"]], "query": "Stripe webhook verification only: vec"}
{"output": [["hyde", "Stripe signs webhooks with your endpoint secret. Verify using stripe.webhooks.constructEvent(body, sig, endpointSecret). Use the raw request body, not parsed JSON. Return 200 quickly, process async. Handle event types like checkout.session.completed. Store endpoint secret securely, rotate if compromised."]], "query": "Stripe webhook verification only: hyde"}
{"output": [["lex", "react context redux comparison"], ["lex", "useContext vs redux state"], ["lex", "react state management choice"]], "query": "React context vs Redux only: lex"}
{"output": [["vec", "when should you use react context versus redux for state management"], ["vec", "what are the tradeoffs between react context api and redux for global state"]], "query": "React context vs Redux only: vec"}
{"output": [["hyde", "Context is built-in, simple for low-frequency updates like themes and auth. Redux adds boilerplate but provides devtools, middleware, time-travel debugging, predictable updates. Context re-renders all consumers on any change; Redux allows granular subscriptions. Use Context for simple cases, Redux for complex state logic."]], "query": "React context vs Redux only: hyde"}
{"output": [["lex", "dns records types a cname mx"], ["lex", "dns configuration records"], ["lex", "domain name system records"]], "query": "DNS records explained only: lex"}
{"output": [["vec", "what are the different types of dns records and what does each one do"], ["vec", "how do you configure dns records for a domain including a, cname, mx, and txt records"]], "query": "DNS records explained only: vec"}
{"output": [["hyde", "A record maps domain to IPv4 address. AAAA for IPv6. CNAME aliases one domain to another (can't be on root domain). MX for mail servers with priority. TXT for verification and SPF/DKIM. NS delegates to nameservers. TTL controls caching duration. Changes propagate based on previous TTL."]], "query": "DNS records explained only: hyde"}
{"output": [["lex", "tmux session window pane"], ["lex", "tmux attach detach session"], ["lex", "tmux commands shortcuts"]], "query": "tmux session management only: lex"}
{"output": [["vec", "how to create and manage tmux sessions for persistent terminal workflows"], ["vec", "what are the essential tmux commands for session, window, and pane management"]], "query": "tmux session management only: vec"}
{"output": [["hyde", "Start session: tmux new -s name. Detach: Ctrl-b d. Reattach: tmux attach -t name. New window: Ctrl-b c. Split pane: Ctrl-b % (vertical), Ctrl-b \" (horizontal). Navigate panes: Ctrl-b arrow. List sessions: tmux ls. Kill session: tmux kill-session -t name. Sessions persist after disconnect."]], "query": "tmux session management only: hyde"}
{"output": [["lex", "utf-8 unicode encoding"], ["lex", "utf8 character encoding bytes"], ["lex", "unicode utf-8 ascii difference"]], "query": "utf-8 encoding explained only: lex"}
{"output": [["vec", "how does utf-8 encoding work and why is it the standard for text"], ["vec", "what is the relationship between unicode and utf-8 and how are characters encoded as bytes"]], "query": "utf-8 encoding explained only: vec"}
{"output": [["hyde", "UTF-8 encodes Unicode code points as 1-4 bytes. ASCII characters (0-127) use 1 byte, compatible with ASCII. Higher code points use more bytes with leading bits indicating length. UTF-8 is self-synchronizing and space-efficient for Latin text. Always specify encoding explicitly when reading/writing files."]], "query": "utf-8 encoding explained only: hyde"}
{"output": [["lex", "microservices communication patterns"], ["lex", "sync async microservice calls"], ["lex", "event driven microservices"]], "query": "microservices communication patterns only: lex"}
{"output": [["vec", "what are the common communication patterns between microservices"], ["vec", "when should microservices use synchronous rest calls versus asynchronous messaging"]], "query": "microservices communication patterns only: vec"}
{"output": [["hyde", "Sync (REST/gRPC): simple, immediate response, but creates coupling and cascade failures. Async (message queues, events): decoupled, resilient, eventual consistency. Use sync for queries needing immediate response. Use async for commands, notifications, cross-service workflows. Event sourcing and CQRS for complex domains."]], "query": "microservices communication patterns only: hyde"}
{"output": [["lex", "bash script best practices"], ["lex", "shell script error handling"], ["lex", "bash scripting guidelines"]], "query": "shell script best practices only: lex"}
{"output": [["vec", "what are the best practices for writing reliable and maintainable shell scripts"], ["vec", "how do you handle errors and edge cases properly in bash scripts"]], "query": "shell script best practices only: vec"}
{"output": [["hyde", "Start with #!/usr/bin/env bash and set -euo pipefail. Use shellcheck for linting. Quote variables: \"$var\". Use [[ ]] for tests. Handle errors with trap. Use functions for reusability. Avoid parsing ls output—use globs. Prefer printf over echo. Use local variables in functions. Add -- before filenames from user input."]], "query": "shell script best practices only: hyde"}
{"output": [["lex", "load balancer health check"], ["lex", "health check endpoint liveness"], ["lex", "lb health probe configuration"]], "query": "load balancer health checks only: lex"}
{"output": [["vec", "how do load balancer health checks work and why are they important"], ["vec", "what should a health check endpoint return and how do you configure health check intervals"]], "query": "load balancer health checks only: vec"}
{"output": [["hyde", "Load balancers probe backend instances to route traffic only to healthy ones. Health endpoint should check critical dependencies (database, cache) and return 200 if healthy, 503 if not. Configure interval (10-30s), timeout (5s), and threshold (2-3 failures). Include /health and /ready endpoints for Kubernetes liveness and readiness."]], "query": "load balancer health checks only: hyde"}
{"output": [["lex", "ssl tls certificate renewal"], ["lex", "lets encrypt certbot renew"], ["lex", "https certificate expiration"]], "query": "certificate ssl tls renewal only: lex"}
{"output": [["vec", "how to renew ssl tls certificates before they expire"], ["vec", "what is the process for automated certificate renewal with lets encrypt and certbot"]], "query": "certificate ssl tls renewal only: vec"}
{"output": [["hyde", "Let's Encrypt certificates expire in 90 days. Certbot auto-renews via cron or systemd timer: certbot renew runs twice daily, renews within 30 days of expiry. Test with --dry-run. For other CAs, set calendar reminders. Check expiration: openssl s_client -connect domain:443 | openssl x509 -noout -dates."]], "query": "certificate ssl tls renewal only: hyde"}
{"output": [["lex", "python decorator function"], ["lex", "python @ decorator syntax"], ["lex", "python wrapper decorator"]], "query": "python decorators explained only: lex"}
{"output": [["vec", "how do python decorators work and what is the syntax for creating them"], ["vec", "what are common use cases for decorators in python like logging, caching, and authentication"]], "query": "python decorators explained only: vec"}
{"output": [["hyde", "Decorators wrap functions to extend behavior. @decorator before def is syntactic sugar for func = decorator(func). A decorator is a function taking a function and returning a new function. Use functools.wraps to preserve metadata. Common uses: @lru_cache for memoization, @login_required for auth, timing/logging wrappers."]], "query": "python decorators explained only: hyde"}
{"output": [["lex", "cap theorem distributed database"], ["lex", "consistency availability partition tolerance"], ["lex", "cap theorem tradeoffs"]], "query": "cap theorem database only: lex"}
{"output": [["vec", "what is the cap theorem and how does it apply to distributed database design"], ["vec", "how do different databases choose between consistency and availability during network partitions"]], "query": "cap theorem database only: vec"}
{"output": [["hyde", "CAP theorem: distributed systems can guarantee only 2 of 3—Consistency (all nodes see same data), Availability (requests get responses), Partition tolerance (survives network splits). During partitions, choose CP (reject requests for consistency, like MongoDB) or AP (serve potentially stale data, like Cassandra). PACELC extends CAP for normal operation tradeoffs."]], "query": "cap theorem database only: hyde"}
{"output": [["lex", "garbage collection gc tuning"], ["lex", "jvm gc heap memory"], ["lex", "gc pause time optimization"]], "query": "garbage collection tuning only: lex"}
{"output": [["vec", "how to tune garbage collection for better application performance"], ["vec", "what gc algorithms are available and how do you choose gc settings for low latency"]], "query": "garbage collection tuning only: vec"}
{"output": [["hyde", "For JVM, G1GC is default, good balance of throughput and pause times. ZGC and Shenandoah offer sub-millisecond pauses for low-latency needs. Tune heap size: -Xms and -Xmx same to avoid resizing. Monitor with gc logs: -Xlog:gc*. Reduce allocation rate by reusing objects and avoiding unnecessary autoboxing."]], "query": "garbage collection tuning only: hyde"}
{"output": [["lex", "feature flags toggles"], ["lex", "feature flag implementation"], ["lex", "gradual rollout feature flags"]], "query": "feature flags implementation only: lex"}
{"output": [["vec", "how to implement feature flags for gradual rollouts and a/b testing"], ["vec", "what are the best practices for managing feature flags in production"]], "query": "feature flags implementation only: vec"}
{"output": [["hyde", "Feature flags decouple deployment from release. Simple: if (featureEnabled('new-checkout')) { ... }. Store flags in config, database, or services like LaunchDarkly. Use for gradual rollout (1% -> 10% -> 100%), A/B tests, kill switches. Clean up old flags to prevent technical debt. Log flag evaluations for debugging."]], "query": "feature flags implementation only: hyde"}
{"output": [["lex", "kafka partitions topics"], ["lex", "kafka partition key ordering"], ["lex", "kafka partition count scaling"]], "query": "apache kafka partitions only: lex"}
{"output": [["vec", "how do kafka partitions work and how do they affect scalability and message ordering"], ["vec", "how do you choose the right number of partitions for a kafka topic"]], "query": "apache kafka partitions only: vec"}
{"output": [["hyde", "Partitions enable parallelism—each partition is consumed by one consumer in a group. Messages with same key go to same partition, preserving order per key. More partitions = more throughput but more overhead. Start with partitions = max(expected throughput / partition throughput, consumer count). Can't reduce partitions, only increase."]], "query": "apache kafka partitions only: hyde"}
{"output": [["lex", "cron job syntax schedule"], ["lex", "crontab expression format"], ["lex", "cron schedule examples"]], "query": "cron job syntax only: lex"}
{"output": [["vec", "how to write cron expressions to schedule jobs at specific times"], ["vec", "what does each field in a crontab entry mean and what are common scheduling patterns"]], "query": "cron job syntax only: vec"}
{"output": [["hyde", "Cron format: minute hour day-of-month month day-of-week command. */5 * * * * runs every 5 minutes. 0 2 * * * runs daily at 2 AM. 0 0 * * 0 runs weekly on Sunday. Use crontab -e to edit. Tools like crontab.guru help build expressions. Consider timezone—cron uses system time."]], "query": "cron job syntax only: hyde"}
{"output": [["lex", "gpg key sign verify"], ["lex", "gpg signature git commits"], ["lex", "pgp key signing encryption"]], "query": "GPG key signing only: lex"}
{"output": [["vec", "how to use gpg keys for signing and verifying files and git commits"], ["vec", "what is the process for creating gpg keys and configuring git to sign commits"]], "query": "GPG key signing only: vec"}
{"output": [["hyde", "Generate key: gpg --full-generate-key. List keys: gpg --list-keys. Sign file: gpg --sign file.txt. Verify: gpg --verify file.txt.gpg. For git: git config --global user.signingkey KEYID, git config --global commit.gpgsign true. Export public key for GitHub: gpg --armor --export KEYID."]], "query": "GPG key signing only: hyde"}
{"output": [["lex", "api versioning strategy"], ["lex", "rest api version url header"], ["lex", "api backward compatibility"]], "query": "api versioning strategies only: lex"}
{"output": [["vec", "what are the different strategies for versioning rest apis"], ["vec", "how do you maintain backward compatibility when evolving an api"]], "query": "api versioning strategies only: vec"}
{"output": [["hyde", "URL versioning (/v1/users) is explicit, easy to route. Header versioning (Accept: application/vnd.api+json;version=1) keeps URLs clean. Query param (?version=1) is simple but pollutes URLs. Prefer additive changes—new fields don't break clients. Deprecate gracefully with sunset headers and migration guides."]], "query": "api versioning strategies only: hyde"}
{"output": [["lex", "mutex semaphore difference"], ["lex", "mutex lock synchronization"], ["lex", "semaphore counting binary"]], "query": "mutex vs semaphore only: lex"}
{"output": [["vec", "what is the difference between a mutex and a semaphore in concurrent programming"], ["vec", "when should you use a mutex versus a semaphore for thread synchronization"]], "query": "mutex vs semaphore only: vec"}
{"output": [["hyde", "Mutex is a binary lock owned by one thread—used for mutual exclusion protecting shared resources. Semaphore is a counter allowing N concurrent accesses—used for limiting concurrency (connection pools, rate limiting). Mutex has ownership (same thread must unlock), semaphore doesn't. Use mutex for critical sections, semaphore for resource counting."]], "query": "mutex vs semaphore only: hyde"}
{"output": [["lex", "json schema validation"], ["lex", "jsonschema validator python"], ["lex", "json schema types required"]], "query": "json schema validation only: lex"}
{"output": [["vec", "how to use json schema to validate the structure of json data"], ["vec", "what are the common json schema keywords for defining types, required fields, and constraints"]], "query": "json schema validation only: vec"}
{"output": [["hyde", "JSON Schema defines expected structure. Key properties: type (string, number, object, array), properties for object fields, required array for mandatory fields, items for array elements. Validators: ajv (JS), jsonschema (Python). Use for API request validation, config file validation, documentation generation."]], "query": "json schema validation only: hyde"}
{"output": [["lex", "ci cd pipeline stages"], ["lex", "continuous integration deployment"], ["lex", "build test deploy pipeline"]], "query": "CI CD pipeline stages only: lex"}
{"output": [["vec", "what are the typical stages in a ci cd pipeline"], ["vec", "how do you design a continuous integration and deployment pipeline for reliable releases"]], "query": "CI CD pipeline stages only: vec"}
{"output": [["hyde", "Typical stages: 1) Source—trigger on commit, 2) Build—compile, bundle, create artifacts, 3) Test—unit, integration, e2e tests, 4) Security scan—SAST, dependency audit, 5) Deploy to staging, 6) Acceptance tests, 7) Deploy to production. Use parallelization for speed. Gate deployments on test pass. Implement rollback mechanisms."]], "query": "CI CD pipeline stages only: hyde"}
{"output": [["lex", "event sourcing pattern"], ["lex", "event store append only log"], ["lex", "cqrs event sourcing"]], "query": "event sourcing pattern only: lex"}
{"output": [["vec", "what is event sourcing and how does it differ from traditional crud data storage"], ["vec", "how do you implement event sourcing and what are its benefits and challenges"]], "query": "event sourcing pattern only: vec"}
{"output": [["hyde", "Event sourcing stores state changes as immutable events rather than current state. Account balance is sum of all Deposit and Withdrawal events. Benefits: full audit trail, time travel, replay for debugging. Challenges: eventual consistency, event schema evolution, increased complexity. Often paired with CQRS—separate read models built from event stream."]], "query": "event sourcing pattern only: hyde"}
{"output": [["lex", "ipv4 ipv6 difference"], ["lex", "ipv6 address format"], ["lex", "ipv4 exhaustion ipv6 transition"]], "query": "IPv4 vs IPv6 only: lex"}
{"output": [["vec", "what are the key differences between ipv4 and ipv6 addressing"], ["vec", "why is ipv6 necessary and how does the transition from ipv4 work"]], "query": "IPv4 vs IPv6 only: vec"}
{"output": [["hyde", "IPv4 uses 32-bit addresses (4 billion), exhausted in 2011. IPv6 uses 128-bit addresses (340 undecillion), formatted as eight hex groups: 2001:0db8::1. IPv6 eliminates NAT need, has built-in IPsec. Transition via dual-stack (both protocols) or tunneling. Check IPv6 support: curl -6 ipv6.google.com."]], "query": "IPv4 vs IPv6 only: hyde"}
{"output": [["lex", "dependency injection di pattern"], ["lex", "di inversion of control ioc"], ["lex", "dependency injection testing"]], "query": "dependency injection benefits only: lex"}
{"output": [["vec", "what is dependency injection and why does it improve code maintainability"], ["vec", "how does dependency injection make unit testing easier"]], "query": "dependency injection benefits only: vec"}
{"output": [["hyde", "Dependency injection provides dependencies from outside rather than creating them internally. Class receives DatabaseService via constructor instead of instantiating it. Benefits: loose coupling, easy testing with mocks, flexible configuration. Instead of new EmailService(), inject interface IEmailService—swap implementations without changing consumer code."]], "query": "dependency injection benefits only: hyde"}
{"output": [["lex", "s3 bucket policy permissions"], ["lex", "aws s3 iam policy json"], ["lex", "s3 bucket access control"]], "query": "S3 bucket policy only: lex"}
{"output": [["vec", "how to write an s3 bucket policy to control access permissions"], ["vec", "what is the difference between s3 bucket policies and iam policies for access control"]], "query": "S3 bucket policy only: vec"}
{"output": [["hyde", "S3 bucket policies are resource-based JSON policies attached to buckets. Grant public read: {\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":\"*\",\"Action\":\"s3:GetObject\",\"Resource\":\"arn:aws:s3:::bucket/*\"}]}. IAM policies attach to users/roles. Use bucket policies for cross-account access, IAM for user-specific permissions. Block public access settings override policies."]], "query": "S3 bucket policy only: hyde"}
{"output": [["lex", "idempotency api design"], ["lex", "idempotent request key"], ["lex", "api retry safety idempotency"]], "query": "idempotency api design only: lex"}
{"output": [["vec", "what is idempotency in api design and why is it important for reliability"], ["vec", "how do you implement idempotent endpoints to handle duplicate requests safely"]], "query": "idempotency api design only: vec"}
{"output": [["hyde", "Idempotent operations produce the same result regardless of how many times called. GET, PUT, DELETE are naturally idempotent. POST needs idempotency keys: client sends unique key, server stores result, returns cached result on retry. Store keys with TTL (24h). Critical for payment APIs—prevents double charges on network retry."]], "query": "idempotency api design only: hyde"}
{"output": [["lex", "awk command examples"], ["lex", "awk print column field"], ["lex", "awk text processing"]], "query": "awk command examples only: lex"}
{"output": [["vec", "how to use awk for text processing and extracting columns from files"], ["vec", "what are common awk patterns and commands for parsing structured text"]], "query": "awk command examples only: vec"}
{"output": [["hyde", "awk processes text line by line, splitting into fields. Print second column: awk '{print $2}' file. Custom delimiter: awk -F',' '{print $1}'. Pattern match: awk '/error/ {print}'. Sum column: awk '{sum+=$3} END {print sum}'. Variables: awk -v threshold=100 '$3 > threshold'. Built-in vars: NF (fields), NR (line number)."]], "query": "awk command examples only: hyde"}
{"output": [["lex", "database sharding horizontal"], ["lex", "shard key partition strategy"], ["lex", "database horizontal scaling"]], "query": "database sharding strategies only: lex"}
{"output": [["vec", "what is database sharding and what strategies exist for partitioning data"], ["vec", "how do you choose a shard key and what are the tradeoffs of different sharding approaches"]], "query": "database sharding strategies only: vec"}
{"output": [["hyde", "Sharding distributes data across multiple databases. Strategies: range-based (user IDs 1-1M on shard 1), hash-based (consistent hashing), directory-based (lookup table). Choose shard key with high cardinality, even distribution, query locality. Avoid hot spots—don't shard by timestamp. Cross-shard queries are expensive. Consider sharding only after vertical scaling exhausted."]], "query": "database sharding strategies only: hyde"}
{"output": [["lex", "jq json parsing command"], ["lex", "jq filter select query"], ["lex", "jq command line json"]], "query": "jq json parsing only: lex"}
{"output": [["vec", "how to use jq to parse and transform json data from the command line"], ["vec", "what are the common jq filters for extracting and manipulating json fields"]], "query": "jq json parsing only: vec"}
{"output": [["hyde", "jq is a command-line JSON processor. Extract field: jq '.name' file.json. Array element: jq '.[0]'. Nested: jq '.users[].email'. Filter: jq '.items[] | select(.price > 100)'. Transform: jq '{name: .title, count: .items | length}'. Raw output: jq -r. Pipe curl output: curl api | jq '.data'."]], "query": "jq json parsing only: hyde"}
{"output": [["lex", "compile time runtime error difference"], ["lex", "static dynamic type checking"], ["lex", "compilation errors vs exceptions"]], "query": "compile time vs runtime errors only: lex"}
{"output": [["vec", "what is the difference between compile time and runtime errors in programming"], ["vec", "why are compile time errors generally preferable to runtime errors for code reliability"]], "query": "compile time vs runtime errors only: vec"}
{"output": [["hyde", "Compile time errors occur during compilation before code runs—syntax errors, type mismatches in statically typed languages. Runtime errors occur during execution—null pointer, division by zero, file not found. Compile time errors are caught early, cheaper to fix. Static typing and linters catch more at compile time. TypeScript catches errors that JavaScript defers to runtime."]], "query": "compile time vs runtime errors only: hyde"}
{"output": [["lex", "cdn content delivery network"], ["lex", "cdn caching edge servers"], ["lex", "cloudflare cdn setup"]], "query": "content delivery network cdn only: lex"}
{"output": [["vec", "how does a content delivery network cdn improve website performance"], ["vec", "what content should you serve through a cdn and how do you configure cache headers"]], "query": "content delivery network cdn only: vec"}
{"output": [["hyde", "CDN caches content at edge servers geographically close to users, reducing latency. Serve static assets (images, CSS, JS) through CDN. Set Cache-Control headers: max-age=31536000 for versioned assets, shorter for dynamic content. Configure origin pulls, purge cache on deploys. Popular CDNs: Cloudflare, CloudFront, Fastly, Akamai."]], "query": "content delivery network cdn only: hyde"}
{"output": [["lex", "circuit breaker pattern"], ["lex", "circuit breaker resilience"], ["lex", "hystrix resilience4j circuit"]], "query": "circuit breaker pattern only: lex"}
{"output": [["vec", "what is the circuit breaker pattern and how does it improve system resilience"], ["vec", "how do you implement circuit breakers to prevent cascade failures in distributed systems"]], "query": "circuit breaker pattern only: vec"}
{"output": [["hyde", "Circuit breaker prevents repeated calls to failing services. States: Closed (normal), Open (failing, reject calls immediately), Half-Open (test recovery). After N failures, opens circuit. After timeout, allows test request. If succeeds, closes. Prevents cascade failures, provides fallbacks. Libraries: resilience4j (Java), polly (.NET), opossum (Node.js)."]], "query": "circuit breaker pattern only: hyde"}
{"output": [["lex", "mac address ip address difference"], ["lex", "mac address layer 2 hardware"], ["lex", "ip vs mac network address"]], "query": "mac address vs ip address only: lex"}
{"output": [["vec", "what is the difference between a mac address and an ip address in networking"], ["vec", "how do mac addresses and ip addresses work together for network communication"]], "query": "mac address vs ip address only: vec"}
{"output": [["hyde", "MAC address is hardware identifier burned into NIC, 48 bits (AA:BB:CC:DD:EE:FF), used in Layer 2 (local network). IP address is logical, assigned by network, used in Layer 3 (routing). ARP maps IP to MAC on local network. IP gets packets between networks, MAC delivers within a network segment. MAC is permanent, IP changes with network."]], "query": "mac address vs ip address only: hyde"}
{"output": [["lex", "unit test integration test difference"], ["lex", "testing pyramid unit integration e2e"], ["lex", "unit test isolation mocking"]], "query": "unit test vs integration test only: lex"}
{"output": [["vec", "what is the difference between unit tests and integration tests"], ["vec", "how should you balance unit tests and integration tests in the testing pyramid"]], "query": "unit test vs integration test only: vec"}
{"output": [["hyde", "Unit tests verify single functions or classes in isolation using mocks for dependencies. Fast, many of them. Integration tests verify components working together with real dependencies. Slower, fewer of them. Testing pyramid: many unit tests at base, fewer integration tests in middle, few e2e tests at top. Unit tests catch logic bugs, integration tests catch interface mismatches."]], "query": "unit test vs integration test only: hyde"}
{"output": [["lex", "base64 encoding decoding"], ["lex", "base64 encode decode string"], ["lex", "base64 binary to text"]], "query": "base64 encoding decoding only: lex"}
{"output": [["vec", "what is base64 encoding and when should you use it"], ["vec", "how do you encode and decode base64 strings in different programming languages"]], "query": "base64 encoding decoding only: vec"}
{"output": [["hyde", "Base64 encodes binary data as ASCII text using 64 characters (A-Z, a-z, 0-9, +, /). Increases size by ~33%. Use for embedding binary in JSON/XML, data URLs, email attachments. Not encryption—easily decoded. In shell: echo -n 'text' | base64. Decode: echo 'dGV4dA==' | base64 -d. In JS: btoa('text'), atob('dGV4dA==')."]], "query": "base64 encoding decoding only: hyde"}
{"output": [["lex", "tail recursion optimization"], ["lex", "tail call optimization tco"], ["lex", "recursive function stack overflow"]], "query": "tail recursion optimization only: lex"}
{"output": [["vec", "what is tail recursion and how does tail call optimization prevent stack overflow"], ["vec", "how do you convert a recursive function to tail recursive form"]], "query": "tail recursion optimization only: vec"}
{"output": [["hyde", "Tail recursion: recursive call is the last operation, no work after it returns. TCO reuses stack frame instead of adding new one—prevents stack overflow. Convert by passing accumulated result as parameter: factorial(n, acc=1) { return n <= 1 ? acc : factorial(n-1, n*acc); }. Not all languages implement TCO—JavaScript in strict mode, Scheme yes, Python no."]], "query": "tail recursion optimization only: hyde"}
{"output": [["lex", "nginx location block config"], ["lex", "nginx location regex prefix"], ["lex", "nginx location matching order"]], "query": "nginx location block only: lex"}
{"output": [["vec", "how do nginx location blocks work and in what order are they matched"], ["vec", "what is the syntax for nginx location directives including prefix and regex matching"]], "query": "nginx location block only: vec"}
{"output": [["hyde", "Location matching order: 1) Exact match (= /path), 2) Preferential prefix (^~ /path), 3) Regex in config order (~* case-insensitive, ~ case-sensitive), 4) Longest prefix match. Example: location /api { proxy_pass http://backend; }. Regex: location ~ \\.php$ { fastcgi_pass; }. Use = for exact matches to skip regex evaluation."]], "query": "nginx location block only: hyde"}
{"output": [["lex", "oop encapsulation abstraction"], ["lex", "object oriented principles"], ["lex", "encapsulation data hiding"]], "query": "oop encapsulation abstraction only: lex"}
{"output": [["vec", "what are encapsulation and abstraction in object oriented programming"], ["vec", "how do encapsulation and abstraction differ and why are they important for software design"]], "query": "oop encapsulation abstraction only: vec"}
{"output": [["hyde", "Encapsulation bundles data and methods, restricting direct access via private fields and public getters/setters. Protects internal state, enables validation. Abstraction hides implementation complexity, exposing only essential interface. Car has accelerate() method—you don't need to know engine internals. Encapsulation is how you hide, abstraction is what you hide."]], "query": "oop encapsulation abstraction only: hyde"}
{"output": [["lex", "webhook vs polling api"], ["lex", "push vs pull api pattern"], ["lex", "webhook callback http"]], "query": "webhook vs api polling only: lex"}
{"output": [["vec", "what are the differences between webhooks and api polling for receiving updates"], ["vec", "when should you use webhooks instead of polling an api for changes"]], "query": "webhook vs api polling only: vec"}
{"output": [["hyde", "Polling: client repeatedly asks server for updates. Simple but wastes bandwidth if nothing changed, may miss events between polls. Webhooks: server pushes updates to client endpoint when events occur. Real-time, efficient, but requires public endpoint and handling failures. Use webhooks when available (Stripe, GitHub), fall back to polling for systems without webhook support."]], "query": "webhook vs api polling only: hyde"}
{"output": [["lex", "database transaction isolation levels"], ["lex", "read committed serializable"], ["lex", "sql isolation dirty read phantom"]], "query": "database transaction isolation levels only: lex"}
{"output": [["vec", "what are the different database transaction isolation levels and their tradeoffs"], ["vec", "how do isolation levels prevent anomalies like dirty reads and phantom reads"]], "query": "database transaction isolation levels only: vec"}
{"output": [["hyde", "Isolation levels from weakest to strongest: Read Uncommitted (dirty reads possible), Read Committed (sees only committed data, default in PostgreSQL), Repeatable Read (no non-repeatable reads), Serializable (no phantom reads, full isolation). Higher isolation = more locking = lower concurrency. Choose based on consistency needs vs performance."]], "query": "database transaction isolation levels only: hyde"}
{"output": [["lex", "hash table collision resolution"], ["lex", "hash map chaining open addressing"], ["lex", "hash collision handling"]], "query": "hash table collision resolution only: lex"}
{"output": [["vec", "how do hash tables handle collisions when multiple keys hash to the same bucket"], ["vec", "what are the differences between chaining and open addressing for collision resolution"]], "query": "hash table collision resolution only: vec"}
{"output": [["hyde", "Chaining: each bucket holds a linked list of entries with same hash. Simple, handles high load well. Open addressing: on collision, probe for next empty slot. Linear probing (check next slot), quadratic probing, double hashing. Better cache locality but degrades at high load factors. Most implementations use chaining (Java HashMap) or open addressing with good probing (Python dict)."]], "query": "hash table collision resolution only: hyde"}
{"output": [["lex", "yaml json config comparison"], ["lex", "yaml vs json syntax"], ["lex", "configuration file format"]], "query": "yaml vs json config only: lex"}
{"output": [["vec", "what are the differences between yaml and json for configuration files"], ["vec", "when should you choose yaml over json for application configuration"]], "query": "yaml vs json config only: vec"}
{"output": [["hyde", "JSON: strict syntax, no comments, explicit quotes, universal parsing. YAML: superset of JSON, allows comments, cleaner for humans, indentation-based. Use JSON for data interchange, APIs, when strict parsing needed. Use YAML for configs (Docker Compose, Kubernetes, CI/CD) where human editing is common. YAML gotchas: Norway problem (NO parsed as false), inconsistent indentation."]], "query": "yaml vs json config only: hyde"}
{"output": [["lex", "kubernetes ingress controller"], ["lex", "k8s ingress nginx traefik"], ["lex", "ingress rules path host"]], "query": "Kubernetes ingress controller only: lex"}
{"output": [["vec", "what is a kubernetes ingress controller and how does it route external traffic to services"], ["vec", "how do you configure ingress rules for path-based and host-based routing in kubernetes"]], "query": "Kubernetes ingress controller only: vec"}
{"output": [["hyde", "Ingress controller implements Ingress resources, routing external HTTP/HTTPS to services. Popular controllers: nginx-ingress, Traefik, HAProxy. Ingress resource defines rules: host (foo.com), paths (/api -> api-service, / -> frontend). Annotations configure TLS, rate limiting, auth. Install controller first, then create Ingress resources."]], "query": "Kubernetes ingress controller only: hyde"}
{"output": [["lex", "docker layer caching build"], ["lex", "dockerfile cache optimization"], ["lex", "docker build cache layers"]], "query": "docker layer caching only: lex"}
{"output": [["vec", "how does docker layer caching work and how do you optimize dockerfiles for faster builds"], ["vec", "what dockerfile practices maximize cache hits when building docker images"]], "query": "docker layer caching only: vec"}
{"output": [["hyde", "Docker caches each instruction as a layer. Cache invalidates when instruction or context changes, invalidating all subsequent layers. Optimization: order from least to most frequently changing. Copy package.json and install deps before copying source code. Use .dockerignore. Multi-stage builds discard intermediate layers. COPY --from for selective extraction."]], "query": "docker layer caching only: hyde"}
{"output": [["lex", "ssh tunnel port forwarding"], ["lex", "ssh local remote forward"], ["lex", "ssh -L -R tunnel"]], "query": "ssh tunnel port forwarding only: lex"}
{"output": [["vec", "how to set up ssh tunnels for local and remote port forwarding"], ["vec", "what is the difference between ssh local port forwarding and remote port forwarding"]], "query": "ssh tunnel port forwarding only: vec"}
{"output": [["hyde", "Local forwarding (-L): access remote service through local port. ssh -L 8080:localhost:3000 server—localhost:8080 reaches server's port 3000. Remote forwarding (-R): expose local service through remote port. ssh -R 8080:localhost:3000 server—server:8080 reaches your port 3000. Use for accessing databases behind firewalls, exposing dev servers temporarily."]], "query": "ssh tunnel port forwarding only: hyde"}
{"output": [["lex", "rest api pagination"], ["lex", "api pagination offset cursor"], ["lex", "paginated response next page"]], "query": "rest api pagination only: lex"}
{"output": [["vec", "what are the different approaches to implementing pagination in rest apis"], ["vec", "how do offset-based and cursor-based pagination compare for api design"]], "query": "rest api pagination only: vec"}
{"output": [["hyde", "Offset pagination: ?page=2&limit=20 or ?offset=20&limit=20. Simple but slow for deep pages, inconsistent with real-time inserts. Cursor pagination: ?cursor=abc123&limit=20, cursor encodes position. Consistent, efficient, better for infinite scroll. Return next_cursor in response. Use Link headers or response body for pagination URLs."]], "query": "rest api pagination only: hyde"}
{"output": [["lex", "solid principles oop"], ["lex", "single responsibility open closed"], ["lex", "solid design principles"]], "query": "solid principles explained only: lex"}
{"output": [["vec", "what are the solid principles in object oriented design"], ["vec", "how do the solid principles improve code maintainability and flexibility"]], "query": "solid principles explained only: vec"}
{"output": [["hyde", "SOLID: Single Responsibility (one reason to change), Open/Closed (open for extension, closed for modification), Liskov Substitution (subtypes substitutable for base types), Interface Segregation (many specific interfaces over one general), Dependency Inversion (depend on abstractions not concretions). Following SOLID produces loosely coupled, testable, maintainable code."]], "query": "solid principles explained only: hyde"}
{"output": [["lex", "protobuf json comparison"], ["lex", "protocol buffers serialization"], ["lex", "grpc protobuf format"]], "query": "protobuf vs json only: lex"}
{"output": [["vec", "what are the differences between protocol buffers and json for data serialization"], ["vec", "when should you use protobuf instead of json for api communication"]], "query": "protobuf vs json only: vec"}
{"output": [["hyde", "JSON: human-readable, self-describing, universal support, larger payload. Protobuf: binary format, 3-10x smaller, faster serialization, requires schema (.proto files), strong typing. Use JSON for public APIs, debugging, human interaction. Use Protobuf for internal microservices, high-throughput systems, gRPC. Schema evolution with field numbers enables backward compatibility."]], "query": "protobuf vs json only: hyde"}
{"output": [["lex", "linux namespaces containers"], ["lex", "container isolation namespace cgroup"], ["lex", "docker linux namespaces"]], "query": "linux namespaces containers only: lex"}
{"output": [["vec", "how do linux namespaces enable container isolation"], ["vec", "what kernel features do docker and containers use for process isolation"]], "query": "linux namespaces containers only: vec"}
{"output": [["hyde", "Containers use Linux namespaces for isolation: PID (process tree), NET (network stack), MNT (filesystem mounts), UTS (hostname), IPC (inter-process communication), USER (user IDs). Cgroups limit resource usage (CPU, memory). Together they isolate processes without full VM overhead. Containers share host kernel but see isolated views of system resources."]], "query": "linux namespaces containers only: hyde"}
{"output": [["lex", "graphql subscriptions websocket"], ["lex", "graphql realtime subscriptions"], ["lex", "graphql subscription server"]], "query": "GraphQL subscriptions websocket only: lex"}
{"output": [["vec", "how do graphql subscriptions work for real-time data updates"], ["vec", "what is the underlying protocol for graphql subscriptions and how do you implement them"]], "query": "GraphQL subscriptions websocket only: vec"}
{"output": [["hyde", "GraphQL subscriptions enable real-time updates via persistent connections. Client subscribes: subscription { messageAdded { text } }. Server pushes when events occur. Typically uses WebSocket with graphql-ws protocol. Server maintains subscription registry, publishes events through PubSub. Apollo Server and Relay support subscriptions natively."]], "query": "GraphQL subscriptions websocket only: hyde"}
{"output": [["lex", "stateless stateful service"], ["lex", "stateless api design"], ["lex", "session state storage"]], "query": "stateless vs stateful services only: lex"}
{"output": [["vec", "what is the difference between stateless and stateful services in application architecture"], ["vec", "why are stateless services easier to scale and how do you handle state when needed"]], "query": "stateless vs stateful services only: vec"}
{"output": [["hyde", "Stateless services don't store client state between requests—any instance can handle any request. Scale by adding instances, no session affinity needed. Stateful services maintain client state, requiring sticky sessions or shared storage. Make services stateless by storing session in JWT tokens, Redis, or databases. Stateless is preferred for horizontal scaling and resilience."]], "query": "stateless vs stateful services only: hyde"}
{"output": [["lex", "git bisect bug finding"], ["lex", "git bisect good bad"], ["lex", "binary search git commit"]], "query": "git bisect debugging only: lex"}
{"output": [["vec", "how to use git bisect to find the commit that introduced a bug"], ["vec", "what is the git bisect workflow for binary search debugging through commit history"]], "query": "git bisect debugging only: vec"}
{"output": [["hyde", "git bisect does binary search through commits to find where bug was introduced. Start: git bisect start, git bisect bad (current has bug), git bisect good v1.0 (known good commit). Git checks out middle commit—test and mark git bisect good or git bisect bad. Repeat until found. Automate with git bisect run ./test.sh. End with git bisect reset."]], "query": "git bisect debugging only: hyde"}
{"output": [["lex", "dns propagation time"], ["lex", "dns ttl propagation delay"], ["lex", "dns changes not working"]], "query": "dns propagation time only: lex"}
{"output": [["vec", "why do dns changes take time to propagate and how can you speed it up"], ["vec", "what is dns propagation and how does ttl affect how quickly changes are visible"]], "query": "dns propagation time only: vec"}
{"output": [["hyde", "DNS propagation is time for changes to spread through cached resolvers worldwide. TTL (Time To Live) controls cache duration. High TTL (86400s) means up to 24h wait. Before changes, lower TTL to 300s, wait for old TTL, make change, then restore TTL. Use dig @8.8.8.8 domain.com to check Google's view. Full propagation can take 24-48h for high-TTL records."]], "query": "dns propagation time only: hyde"}
{"output": [["lex", "roman empire fall causes"], ["lex", "decline of rome 476 AD"], ["lex", "western roman empire collapse"]], "query": "fall of the Roman Empire only: lex"}
{"output": [["vec", "what were the main causes of the fall of the western roman empire"], ["vec", "how did economic, military, and political factors contribute to rome's collapse"]], "query": "fall of the Roman Empire only: vec"}
{"output": [["hyde", "The Western Roman Empire fell in 476 AD when Odoacer deposed Romulus Augustulus. Contributing factors included economic troubles, military overextension, political instability with rapid emperor turnover, pressure from Germanic tribes, and the division of the empire. The Eastern Roman Empire (Byzantine) survived until 1453."]], "query": "fall of the Roman Empire only: hyde"}
{"output": [["lex", "world war 1 causes"], ["lex", "ww1 assassination archduke franz ferdinand"], ["lex", "causes great war 1914"]], "query": "causes of World War I only: lex"}
{"output": [["vec", "what were the main causes and triggers of world war one"], ["vec", "how did the assassination of archduke franz ferdinand lead to a global war"]], "query": "causes of World War I only: vec"}
{"output": [["hyde", "WWI was caused by MAIN: Militarism, Alliances, Imperialism, Nationalism. The assassination of Archduke Franz Ferdinand on June 28, 1914 in Sarajevo triggered a chain reaction through alliance systems. Austria-Hungary declared war on Serbia, pulling in Russia, Germany, France, and Britain within weeks."]], "query": "causes of World War I only: hyde"}
{"output": [["lex", "egyptian pyramids how built"], ["lex", "pyramid construction ancient egypt"], ["lex", "great pyramid giza building"]], "query": "ancient Egypt pyramids construction only: lex"}
{"output": [["vec", "how were the ancient egyptian pyramids constructed without modern technology"], ["vec", "what techniques and labor did ancient egyptians use to build the pyramids at giza"]], "query": "ancient Egypt pyramids construction only: vec"}
{"output": [["hyde", "The pyramids were built using ramps, levers, and organized labor forces of tens of thousands of workers. Limestone blocks weighing 2.5 tons average were quarried nearby and transported on sledges. Workers were not slaves but paid laborers housed in nearby villages. The Great Pyramid took approximately 20 years to complete around 2560 BC."]], "query": "ancient Egypt pyramids construction only: hyde"}
{"output": [["lex", "french revolution timeline events"], ["lex", "french revolution 1789 bastille"], ["lex", "reign of terror robespierre"]], "query": "French Revolution timeline only: lex"}
{"output": [["vec", "what were the major events of the french revolution in chronological order"], ["vec", "how did the french revolution progress from the storming of the bastille to napoleon"]], "query": "French Revolution timeline only: vec"}
{"output": [["hyde", "1789: Estates-General convenes, Bastille stormed July 14. 1791: Constitutional monarchy established. 1792: Republic declared, king executed. 1793-94: Reign of Terror under Robespierre, 17,000 guillotined. 1794: Thermidorian Reaction ends Terror. 1799: Napoleon's coup establishes Consulate."]], "query": "French Revolution timeline only: hyde"}
{"output": [["lex", "ottoman empire history"], ["lex", "ottoman sultanate 1299 1922"], ["lex", "turkish ottoman empire rise fall"]], "query": "Ottoman Empire history only: lex"}
{"output": [["vec", "what was the history of the ottoman empire from its founding to its dissolution"], ["vec", "how did the ottoman empire rise to become a major world power and eventually decline"]], "query": "Ottoman Empire history only: vec"}
{"output": [["hyde", "Founded by Osman I around 1299, the Ottoman Empire conquered Constantinople in 1453, ending the Byzantine Empire. At its peak under Suleiman the Magnificent (1520-1566), it controlled Southeast Europe, Western Asia, and North Africa. Gradual decline through the 18th-19th centuries culminated in dissolution after WWI in 1922."]], "query": "Ottoman Empire history only: hyde"}
{"output": [["lex", "american civil war battles"], ["lex", "civil war gettysburg antietam"], ["lex", "union confederate battles 1861"]], "query": "American Civil War battles only: lex"}
{"output": [["vec", "what were the major battles of the american civil war"], ["vec", "which battles were turning points in the civil war between union and confederate forces"]], "query": "American Civil War battles only: vec"}
{"output": [["hyde", "Major battles: Fort Sumter (1861, war begins), Bull Run (Confederate victory), Antietam (1862, bloodiest single day, led to Emancipation Proclamation), Gettysburg (1863, Union turning point), Vicksburg (Union controls Mississippi), Sherman's March (1864), Appomattox (1865, Lee surrenders). Total casualties exceeded 600,000."]], "query": "American Civil War battles only: hyde"}
{"output": [["lex", "ming dynasty china history"], ["lex", "ming dynasty 1368 1644"], ["lex", "chinese ming emperors"]], "query": "Ming Dynasty China only: lex"}
{"output": [["vec", "what were the major achievements and characteristics of the ming dynasty in china"], ["vec", "how did the ming dynasty rise to power and what led to its eventual fall"]], "query": "Ming Dynasty China only: vec"}
{"output": [["hyde", "The Ming Dynasty (1368-1644) was founded by Zhu Yuanzhang after overthrowing Mongol Yuan rule. Notable achievements: construction of the Forbidden City, voyages of Zheng He, restoration of the Great Wall, and flourishing arts and porcelain. Fell to the Manchu Qing after peasant rebellions weakened central authority."]], "query": "Ming Dynasty China only: hyde"}
{"output": [["lex", "viking age exploration"], ["lex", "vikings norse exploration america"], ["lex", "viking raids settlements"]], "query": "Viking Age exploration only: lex"}
{"output": [["vec", "where did the vikings explore and settle during the viking age"], ["vec", "what routes did norse explorers take and what lands did they discover"]], "query": "Viking Age exploration only: vec"}
{"output": [["hyde", "The Viking Age (793-1066 AD) saw Norse expansion across Europe and beyond. Vikings raided British Isles and France, settled Iceland (874), Greenland (985), and reached North America (Vinland, c.1000) under Leif Erikson. They also traveled east through Russia to Constantinople and served as Varangian Guard."]], "query": "Viking Age exploration only: hyde"}
{"output": [["lex", "industrial revolution inventions"], ["lex", "industrial revolution steam engine"], ["lex", "18th century industrial innovations"]], "query": "Industrial Revolution inventions only: lex"}
{"output": [["vec", "what were the key inventions that drove the industrial revolution"], ["vec", "how did the steam engine and textile machinery transform manufacturing in the 18th century"]], "query": "Industrial Revolution inventions only: vec"}
{"output": [["hyde", "Key inventions: Spinning Jenny (1764), Water Frame (1769), Steam Engine improved by James Watt (1769), Power Loom (1785), Cotton Gin (1793), Steam Locomotive (1804). These enabled factory production, mass manufacturing, and transformed society from agricultural to industrial. Britain led the revolution starting around 1760."]], "query": "Industrial Revolution inventions only: hyde"}
{"output": [["lex", "byzantine empire constantinople"], ["lex", "eastern roman empire byzantium"], ["lex", "fall of constantinople 1453"]], "query": "Byzantine Empire Constantinople only: lex"}
{"output": [["vec", "what was the byzantine empire and how long did it last after rome fell"], ["vec", "how did constantinople serve as the capital of the byzantine empire until 1453"]], "query": "Byzantine Empire Constantinople only: vec"}
{"output": [["hyde", "The Byzantine Empire was the continuation of the Eastern Roman Empire, lasting from 330 AD (Constantinople founded) to 1453. At its peak under Justinian I, it reconquered much of the western Mediterranean. Constantinople was the largest and wealthiest European city for centuries until falling to Ottoman Turks under Mehmed II on May 29, 1453."]], "query": "Byzantine Empire Constantinople only: hyde"}
{"output": [["lex", "aztec empire civilization"], ["lex", "aztec tenochtitlan mexico"], ["lex", "aztec history mesoamerica"]], "query": "Aztec Empire civilization only: lex"}
{"output": [["vec", "what was the aztec empire and how did their civilization develop in mesoamerica"], ["vec", "how did the aztecs build tenochtitlan and what led to the fall of their empire"]], "query": "Aztec Empire civilization only: vec"}
{"output": [["hyde", "The Aztec Empire (1428-1521) dominated central Mexico from their capital Tenochtitlan, built on an island in Lake Texcoco (modern Mexico City). Population reached 200,000+. Known for pyramids, human sacrifice, chinampas (floating gardens), and tribute system. Conquered by Hernán Cortés in 1521 with help from rival indigenous groups and smallpox."]], "query": "Aztec Empire civilization only: hyde"}
{"output": [["lex", "renaissance italy florence"], ["lex", "italian renaissance medici"], ["lex", "florence renaissance art"]], "query": "Renaissance Italy Florence only: lex"}
{"output": [["vec", "why did the renaissance begin in italy particularly in florence"], ["vec", "how did the medici family and florence become the center of the italian renaissance"]], "query": "Renaissance Italy Florence only: vec"}
{"output": [["hyde", "The Renaissance began in Florence around 1400 due to wealth from banking and trade, political stability, and classical heritage. The Medici family, especially Lorenzo the Magnificent, patronized artists like Leonardo, Michelangelo, and Botticelli. Florence's guilds, humanism from rediscovered Greek texts, and competition among city-states drove cultural innovation."]], "query": "Renaissance Italy Florence only: hyde"}
{"output": [["lex", "cold war berlin wall"], ["lex", "berlin wall 1961 1989"], ["lex", "east west germany division"]], "query": "Cold War Berlin Wall only: lex"}
{"output": [["vec", "what was the significance of the berlin wall during the cold war"], ["vec", "why was the berlin wall built and what led to its fall in 1989"]], "query": "Cold War Berlin Wall only: vec"}
{"output": [["hyde", "The Berlin Wall was built overnight on August 13, 1961 by East Germany to stop emigration to the West—3.5 million had fled since 1945. It divided Berlin for 28 years, symbolizing the Iron Curtain. Fell November 9, 1989 after Hungary opened its border and East German protests grew. Germany reunified October 3, 1990."]], "query": "Cold War Berlin Wall only: hyde"}
{"output": [["lex", "mongol empire genghis khan"], ["lex", "mongol conquests 13th century"], ["lex", "genghis khan mongol history"]], "query": "Mongol Empire Genghis Khan only: lex"}
{"output": [["vec", "how did genghis khan build the mongol empire into the largest contiguous land empire"], ["vec", "what territories did the mongol empire conquer and how did they administer such vast lands"]], "query": "Mongol Empire Genghis Khan only: vec"}
{"output": [["hyde", "Genghis Khan united Mongol tribes by 1206 and conquered from Korea to Poland by his death in 1227. The empire peaked under his grandsons, spanning 24 million km²—largest contiguous empire ever. Success came from cavalry tactics, meritocracy, religious tolerance, and the Yam relay system. Divided into khanates after 1260."]], "query": "Mongol Empire Genghis Khan only: hyde"}
{"output": [["lex", "ancient greece democracy athens"], ["lex", "athenian democracy 5th century bc"], ["lex", "greek democracy origins"]], "query": "ancient Greece democracy Athens only: lex"}
{"output": [["vec", "how did democracy develop in ancient athens and how did it function"], ["vec", "what were the key institutions and practices of athenian democracy"]], "query": "ancient Greece democracy Athens only: vec"}
{"output": [["hyde", "Athenian democracy emerged under Cleisthenes (508 BC) and peaked under Pericles (461-429 BC). Citizens (adult male non-slaves) voted directly in the Assembly (Ekklesia) on laws and policy. The Council of 500, chosen by lot, set the agenda. Jury courts had hundreds of jurors. About 30,000 of 300,000 residents were citizens."]], "query": "ancient Greece democracy Athens only: hyde"}
{"output": [["lex", "protestant reformation luther"], ["lex", "martin luther 95 theses"], ["lex", "reformation 1517 catholic church"]], "query": "Protestant Reformation Martin Luther only: lex"}
{"output": [["vec", "what started the protestant reformation and what were its main ideas"], ["vec", "how did martin luther's 95 theses challenge the catholic church and spread across europe"]], "query": "Protestant Reformation Martin Luther only: vec"}
{"output": [["hyde", "Martin Luther posted his 95 Theses on October 31, 1517 in Wittenberg, criticizing indulgences and papal authority. Key ideas: salvation by faith alone, scripture as sole authority, priesthood of all believers. The printing press spread his ideas rapidly. Luther was excommunicated in 1521. The Reformation split Western Christianity and sparked religious wars across Europe."]], "query": "Protestant Reformation Martin Luther only: hyde"}
{"output": [["lex", "silk road trade route"], ["lex", "silk road ancient trade china"], ["lex", "silk road history commerce"]], "query": "Silk Road trade routes only: lex"}
{"output": [["vec", "what was the silk road and how did it connect east and west"], ["vec", "what goods and ideas were exchanged along the ancient silk road trade routes"]], "query": "Silk Road trade routes only: vec"}
{"output": [["hyde", "The Silk Road was a network of trade routes connecting China to the Mediterranean from around 130 BC to 1450s AD. Goods traded: silk, spices, porcelain from East; gold, glass, horses from West. Also spread Buddhism, Islam, technologies like paper and gunpowder, and unfortunately, the Black Death. Named by German geographer Ferdinand von Richthofen in 1877."]], "query": "Silk Road trade routes only: hyde"}
{"output": [["lex", "napoleonic wars europe"], ["lex", "napoleon bonaparte campaigns"], ["lex", "napoleonic era 1803 1815"]], "query": "Napoleonic Wars Europe only: lex"}
{"output": [["vec", "what were the major campaigns and outcomes of the napoleonic wars"], ["vec", "how did napoleon's military conquests reshape europe and lead to his downfall"]], "query": "Napoleonic Wars Europe only: vec"}
{"output": [["hyde", "The Napoleonic Wars (1803-1815) saw France under Napoleon dominate continental Europe through brilliant campaigns at Austerlitz, Jena, and Wagram. His empire stretched from Spain to Poland. The failed 1812 Russian invasion (600,000 troops, 100,000 returned) began his decline. Exiled to Elba 1814, returned for Hundred Days, finally defeated at Waterloo June 18, 1815."]], "query": "Napoleonic Wars Europe only: hyde"}
{"output": [["lex", "ancient mesopotamia civilizations"], ["lex", "mesopotamia sumer babylon"], ["lex", "cradle of civilization tigris euphrates"]], "query": "ancient Mesopotamia civilizations only: lex"}
{"output": [["vec", "what civilizations arose in ancient mesopotamia and what were their achievements"], ["vec", "why is mesopotamia called the cradle of civilization and what did sumerians invent"]], "query": "ancient Mesopotamia civilizations only: vec"}
{"output": [["hyde", "Mesopotamia (modern Iraq) between Tigris and Euphrates rivers hosted the world's first civilizations. Sumerians (4500-1900 BC) invented writing (cuneiform), the wheel, sailboat, and plow. Akkadian Empire under Sargon was first empire. Babylon produced Hammurabi's Code. Assyrians and Persians followed. Agriculture surplus enabled cities, specialization, and complex society."]], "query": "ancient Mesopotamia civilizations only: hyde"}
{"output": [["lex", "meiji restoration japan"], ["lex", "meiji era modernization 1868"], ["lex", "japan meiji emperor reform"]], "query": "Meiji Restoration Japan only: lex"}
{"output": [["vec", "what was the meiji restoration and how did it transform japan"], ["vec", "how did japan modernize so rapidly during the meiji period from 1868 to 1912"]], "query": "Meiji Restoration Japan only: vec"}
{"output": [["hyde", "The Meiji Restoration (1868) ended 250 years of Tokugawa shogunate rule, restoring imperial power under Emperor Meiji. Japan rapidly industrialized and westernized: abolished feudalism, created national army, built railways, established constitution (1889). Slogan: 'Rich country, strong army.' Japan defeated China (1895) and Russia (1905), becoming a world power within 50 years."]], "query": "Meiji Restoration Japan only: hyde"}
{"output": [["lex", "black death plague europe"], ["lex", "bubonic plague 1347 medieval"], ["lex", "black death medieval europe"]], "query": "Black Death plague Europe only: lex"}
{"output": [["vec", "what was the black death and how did it impact medieval europe"], ["vec", "how did the bubonic plague spread across europe and what were its consequences"]], "query": "Black Death plague Europe only: vec"}
{"output": [["hyde", "The Black Death (1347-1351) killed 75-200 million people, 30-60% of Europe's population. Caused by Yersinia pestis bacteria spread by fleas on rats, it arrived via Genoese ships from Crimea. Symptoms: buboes, fever, death within days. Consequences: labor shortages raised wages, weakened feudalism, sparked religious movements and persecution of Jews."]], "query": "Black Death plague Europe only: hyde"}
{"output": [["lex", "spanish conquest americas"], ["lex", "conquistadors cortez pizarro"], ["lex", "spanish colonization new world"]], "query": "Spanish Conquest Americas only: lex"}
{"output": [["vec", "how did spanish conquistadors conquer the aztec and inca empires"], ["vec", "what factors enabled spain to colonize the americas so rapidly in the 16th century"]], "query": "Spanish Conquest Americas only: vec"}
{"output": [["hyde", "Hernán Cortés conquered the Aztec Empire (1519-1521) with 500 soldiers, allying with Tlaxcalans and exploiting Montezuma's hesitation. Francisco Pizarro conquered the Inca Empire (1532-1533) capturing Atahualpa during civil war. Spanish advantages: steel weapons, horses, gunpowder, and crucially, Old World diseases like smallpox that killed 90% of indigenous populations."]], "query": "Spanish Conquest Americas only: hyde"}
{"output": [["lex", "world war 2 d-day normandy"], ["lex", "d-day june 6 1944 invasion"], ["lex", "operation overlord ww2"]], "query": "World War II D-Day only: lex"}
{"output": [["vec", "what happened on d-day and why was the normandy invasion a turning point in world war two"], ["vec", "how was the d-day invasion of normandy planned and executed by allied forces"]], "query": "World War II D-Day only: vec"}
{"output": [["hyde", "D-Day, June 6, 1944, was the largest amphibious invasion in history. Operation Overlord landed 156,000 Allied troops on five Normandy beaches (Utah, Omaha, Gold, Juno, Sword). Despite 10,000+ casualties, it established a Western Front, leading to Paris liberation (August 1944) and Germany's surrender (May 1945). Supreme Commander: Dwight D. Eisenhower."]], "query": "World War II D-Day only: hyde"}
{"output": [["lex", "han dynasty china achievements"], ["lex", "han dynasty 206 bc history"], ["lex", "ancient china han empire"]], "query": "Han Dynasty China achievements only: lex"}
{"output": [["vec", "what were the major achievements and contributions of the han dynasty in china"], ["vec", "why is the han dynasty considered a golden age in chinese history"]], "query": "Han Dynasty China achievements only: vec"}
{"output": [["hyde", "The Han Dynasty (206 BC - 220 AD) is considered China's golden age. Achievements: Silk Road trade established, paper invented (105 AD), civil service exams introduced, Confucianism became state ideology. Population reached 60 million. So influential that ethnic Chinese still call themselves 'Han people.' Collapsed due to court intrigue, eunuch power, and Yellow Turban Rebellion."]], "query": "Han Dynasty China achievements only: hyde"}
