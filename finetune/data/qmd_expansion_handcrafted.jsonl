{"output": [["lex", "ssh key auth setup"], ["lex", "ssh public private key pair"], ["lex", "passwordless ssh login"], ["vec", "how to set up ssh key-based authentication instead of passwords"], ["vec", "step-by-step guide to generating and configuring ssh keys for secure server access"], ["hyde", "Generate an SSH key pair with ssh-keygen -t ed25519. Copy the public key to ~/.ssh/authorized_keys on the remote server using ssh-copy-id. Ensure permissions are 700 for .ssh and 600 for authorized_keys."]], "query": "ssh key authentication"}
{"output": [["lex", "python venv virtualenv"], ["lex", "pip virtual environment setup"], ["lex", "python isolated dependencies"], ["vec", "how to create and activate a python virtual environment for project isolation"], ["vec", "what is the difference between venv, virtualenv, and conda for managing python dependencies"], ["hyde", "Create a virtual environment with python -m venv myenv, then activate it with source myenv/bin/activate on Unix or myenv\\Scripts\\activate on Windows. Install packages with pip and they stay isolated from your system Python."]], "query": "Python virtual environments"}
{"output": [["lex", "git merge conflict resolve"], ["lex", "git conflict markers HEAD"], ["lex", "resolving merge conflicts"], ["vec", "how to resolve merge conflicts in git when two branches modify the same lines"], ["vec", "what do the conflict markers mean and how do you manually edit conflicted files"], ["hyde", "Git marks conflicts with <<<<<<< HEAD, =======, and >>>>>>> branch-name. Edit the file to keep the code you want, remove the markers, then git add the file and commit. Use git mergetool for a visual diff interface."]], "query": "git merge conflicts"}
{"output": [["lex", "tcp udp protocol difference"], ["lex", "tcp reliable udp fast"], ["lex", "connection-oriented vs connectionless"], ["vec", "what are the key differences between TCP and UDP network protocols"], ["vec", "when should you use TCP versus UDP for application networking"], ["hyde", "TCP provides reliable, ordered delivery with acknowledgments and retransmission. UDP is faster but unreliable—packets may arrive out of order or not at all. Use TCP for web, email, file transfer. Use UDP for video streaming, gaming, DNS where speed matters more than reliability."]], "query": "TCP vs UDP"}
{"output": [["lex", "docker compose volume mount"], ["lex", "docker persistent storage volumes"], ["lex", "compose yaml volumes section"], ["vec", "how to configure persistent volumes in docker compose for data that survives container restarts"], ["vec", "what is the difference between bind mounts and named volumes in docker compose"], ["hyde", "In docker-compose.yml, define volumes under the top-level volumes key and reference them in services. Named volumes persist data in Docker's storage. Bind mounts map host directories directly: volumes: - ./data:/app/data for development, - myvolume:/app/data for production."]], "query": "Docker compose volumes"}
{"output": [["lex", "regex lookahead assertion"], ["lex", "regex lookbehind positive negative"], ["lex", "zero-width assertions regex"], ["vec", "how do lookahead and lookbehind assertions work in regular expressions"], ["vec", "what is the syntax for positive and negative lookahead and lookbehind in regex"], ["hyde", "Lookahead (?=pattern) matches a position followed by pattern without consuming it. Negative lookahead (?!pattern) matches where pattern doesn't follow. Lookbehind (?<=pattern) matches a position preceded by pattern. Example: \\d+(?= dollars) matches numbers followed by 'dollars'."]], "query": "regex lookahead lookbehind"}
{"output": [["lex", "kubernetes secrets k8s"], ["lex", "k8s secret yaml base64"], ["lex", "kubectl create secret"], ["vec", "how to create and use secrets in kubernetes for sensitive configuration data"], ["vec", "what are best practices for managing secrets in kubernetes clusters"], ["hyde", "Create secrets with kubectl create secret generic mysecret --from-literal=password=abc123. Reference in pods via env valueFrom secretKeyRef or volume mounts. Secrets are base64 encoded, not encrypted—use sealed-secrets or external secret managers like Vault for production."]], "query": "Kubernetes secrets management"}
{"output": [["lex", "cors error fix browser"], ["lex", "access-control-allow-origin header"], ["lex", "cors preflight request"], ["vec", "how to fix CORS errors when making API requests from a web browser"], ["vec", "what causes cross-origin resource sharing errors and how do you configure the server to allow them"], ["hyde", "CORS errors occur when a browser blocks requests to a different origin. Fix by adding Access-Control-Allow-Origin headers on the server. For Express: app.use(cors()). For preflight requests, handle OPTIONS and return Access-Control-Allow-Methods and Access-Control-Allow-Headers."]], "query": "CORS errors fix"}
{"output": [["lex", "postgresql index explain analyze"], ["lex", "postgres btree index performance"], ["lex", "create index postgresql"], ["vec", "how to use EXPLAIN ANALYZE to understand query performance and index usage in postgresql"], ["vec", "what types of indexes does postgresql support and when should you use each"], ["hyde", "Run EXPLAIN ANALYZE SELECT... to see the query plan and actual execution time. Look for Seq Scan on large tables—add an index with CREATE INDEX idx_name ON table(column). B-tree indexes work for equality and range queries, GIN for full-text search and arrays, GiST for geometric data."]], "query": "PostgreSQL indexes explain"}
{"output": [["lex", "jwt refresh token flow"], ["lex", "access token refresh token"], ["lex", "jwt token expiration renewal"], ["vec", "how does the jwt refresh token flow work for maintaining user sessions"], ["vec", "what is the difference between access tokens and refresh tokens in jwt authentication"], ["hyde", "Access tokens are short-lived (15 min) and sent with each request. Refresh tokens are long-lived (days/weeks) and stored securely. When the access token expires, send the refresh token to /auth/refresh to get a new access token without re-authenticating."]], "query": "JWT token refresh"}
{"output": [["lex", "systemd service unit file"], ["lex", "systemctl enable start service"], ["lex", "systemd service configuration"], ["vec", "how to create a systemd service file to run an application as a linux daemon"], ["vec", "what are the essential sections and directives in a systemd unit file"], ["hyde", "Create /etc/systemd/system/myapp.service with [Unit] Description, [Service] ExecStart=/path/to/app, Restart=always, User=appuser, and [Install] WantedBy=multi-user.target. Run systemctl daemon-reload, then systemctl enable --now myapp."]], "query": "systemd service file"}
{"output": [["lex", "websocket http difference"], ["lex", "websocket persistent connection"], ["lex", "http polling vs websocket"], ["vec", "what are the differences between websockets and http for real-time communication"], ["vec", "when should you use websockets instead of http long polling or server-sent events"], ["hyde", "HTTP is request-response: client asks, server answers, connection closes. WebSocket upgrades HTTP to a persistent bidirectional connection. Use WebSocket for chat, live updates, gaming. Use SSE for server-to-client only streaming. HTTP polling wastes bandwidth with repeated requests."]], "query": "websocket vs http"}
{"output": [["lex", "sql injection prevent parameterized"], ["lex", "prepared statements sql injection"], ["lex", "sql injection sanitize input"], ["vec", "how to prevent sql injection attacks in web applications"], ["vec", "why are parameterized queries and prepared statements important for database security"], ["hyde", "Never concatenate user input into SQL strings. Use parameterized queries: cursor.execute('SELECT * FROM users WHERE id = ?', (user_id,)). ORMs like SQLAlchemy handle this automatically. Validate and sanitize input, but parameterization is the primary defense."]], "query": "SQL injection prevention"}
{"output": [["lex", "typescript generics type parameter"], ["lex", "typescript generic function interface"], ["lex", "ts generics constraints extends"], ["vec", "how to use generics in typescript to write reusable type-safe functions and classes"], ["vec", "what is the syntax for generic type parameters and constraints in typescript"], ["hyde", "Generics let you write flexible, reusable code while maintaining type safety. Declare with angle brackets: function identity<T>(arg: T): T { return arg; }. Add constraints with extends: function getLength<T extends { length: number }>(item: T): number { return item.length; }."]], "query": "TypeScript generics"}
{"output": [["lex", "oauth2 authorization code flow"], ["lex", "oauth authorization code grant"], ["lex", "oauth2 pkce code verifier"], ["vec", "how does the oauth 2.0 authorization code flow work for secure third-party authentication"], ["vec", "what are the steps in the oauth authorization code grant and why is pkce recommended"], ["hyde", "User clicks login, redirected to auth server with client_id and redirect_uri. User authenticates, gets authorization code. App exchanges code for tokens at token endpoint. PKCE adds code_verifier/code_challenge to prevent interception attacks—required for public clients."]], "query": "OAuth 2.0 authorization code flow"}
{"output": [["lex", "redis cache strategy pattern"], ["lex", "redis cache aside through"], ["lex", "redis ttl expiration caching"], ["vec", "what are the common caching strategies when using redis for application performance"], ["vec", "how do you implement cache-aside, write-through, and write-behind patterns with redis"], ["hyde", "Cache-aside: app checks Redis first, fetches from DB on miss, writes to cache. Write-through: writes go to cache and DB together. Write-behind: writes to cache, async sync to DB. Set TTL with EXPIRE to prevent stale data. Use SETEX for atomic set-with-expiry."]], "query": "Redis caching strategies"}
{"output": [["lex", "graphql rest api comparison"], ["lex", "graphql query flexibility"], ["lex", "rest vs graphql tradeoffs"], ["vec", "what are the main differences between graphql and rest api design approaches"], ["vec", "when should you choose graphql over rest for your api architecture"], ["hyde", "REST uses fixed endpoints returning predefined data shapes. GraphQL uses one endpoint where clients specify exactly what fields they need, reducing over-fetching. REST is simpler, better cached. GraphQL excels for mobile apps, complex data requirements, and avoiding multiple round trips."]], "query": "GraphQL vs REST"}
{"output": [["lex", "linux chmod file permissions"], ["lex", "unix rwx permission bits"], ["lex", "chmod 755 644 meaning"], ["vec", "how do linux file permissions work and how do you change them with chmod"], ["vec", "what do the rwx permission bits mean for owner, group, and others"], ["hyde", "Permissions are rwx for read, write, execute. Three groups: owner, group, others. chmod 755 means rwxr-xr-x (owner full, others read+execute). chmod 644 means rw-r--r-- (owner read+write, others read only). Use chmod +x to add execute permission."]], "query": "linux file permissions chmod"}
{"output": [["lex", "async await try catch"], ["lex", "javascript promise error handling"], ["lex", "async function exception handling"], ["vec", "how to properly handle errors in javascript async await functions"], ["vec", "what happens when an async function throws and how do you catch those errors"], ["hyde", "Wrap await calls in try-catch blocks: try { const data = await fetchData(); } catch (err) { console.error(err); }. Unhandled rejections in async functions become unhandled promise rejections. For multiple awaits, catch individually or use Promise.allSettled to handle partial failures."]], "query": "async await error handling"}
{"output": [["lex", "terraform state file backend"], ["lex", "terraform remote state s3"], ["lex", "tfstate locking management"], ["vec", "how to manage terraform state files and what are the best practices for team collaboration"], ["vec", "why should you use remote state backends in terraform and how do you configure them"], ["hyde", "Store state remotely in S3, GCS, or Terraform Cloud—never commit tfstate to git. Configure backend in terraform { backend \"s3\" { bucket = \"my-state\", key = \"prod.tfstate\", region = \"us-east-1\", dynamodb_table = \"tf-locks\" } }. DynamoDB provides state locking to prevent concurrent modifications."]], "query": "terraform state management"}
{"output": [["lex", "monorepo polyrepo comparison"], ["lex", "monorepo benefits drawbacks"], ["lex", "single repo multiple repos"], ["vec", "what are the tradeoffs between using a monorepo versus multiple repositories"], ["vec", "when does a monorepo make sense and what tools help manage large monorepos"], ["hyde", "Monorepos keep all code in one repository—easier atomic changes across packages, shared tooling, consistent versioning. Polyrepos give teams autonomy, simpler CI, clearer ownership. Use monorepos for tightly coupled code. Tools: Nx, Turborepo, Lerna, Bazel for build orchestration."]], "query": "monorepo vs polyrepo"}
{"output": [["lex", "css flexbox center align"], ["lex", "flexbox justify-content align-items"], ["lex", "css center div flexbox"], ["vec", "how to center elements horizontally and vertically using css flexbox"], ["vec", "what flexbox properties do you use to center content in a container"], ["hyde", "On the container, set display: flex; justify-content: center; align-items: center;. justify-content handles the main axis (horizontal by default), align-items handles the cross axis. Add height: 100vh to center within the viewport. For a single item, margin: auto also works inside flex containers."]], "query": "CSS flexbox centering"}
{"output": [["lex", "database connection pool"], ["lex", "connection pooling performance"], ["lex", "db pool size configuration"], ["vec", "what is database connection pooling and why does it improve application performance"], ["vec", "how do you configure connection pool size for optimal database throughput"], ["hyde", "Opening database connections is expensive. Connection pools maintain reusable connections. Set pool size based on: pool_size = (core_count * 2) + effective_spindle_count. Too small starves the app, too large overwhelms the database. Popular libraries: HikariCP for Java, pgbouncer for PostgreSQL."]], "query": "database connection pooling"}
{"output": [["lex", "kafka consumer group offset"], ["lex", "kafka partition consumer rebalance"], ["lex", "kafka consumer group id"], ["vec", "how do kafka consumer groups work for parallel message processing"], ["vec", "what happens during consumer group rebalancing and how are partitions assigned"], ["hyde", "Consumers with the same group.id share partitions—each partition is consumed by only one consumer in the group. Adding consumers triggers rebalancing. If consumers > partitions, some idle. Offsets track progress per partition. Use enable.auto.commit=false for exactly-once semantics with manual commits."]], "query": "kafka consumer groups"}
{"output": [["lex", "vim search replace substitute"], ["lex", "vim sed command :%s"], ["lex", "vim find replace regex"], ["vec", "how to search and replace text in vim using the substitute command"], ["vec", "what is the syntax for vim search and replace with regular expressions and flags"], ["hyde", "Use :%s/old/new/g to replace all occurrences in the file. % means all lines, g means global (all matches per line). Add c for confirmation: :%s/old/new/gc. Use \\< and \\> for word boundaries. & in replacement refers to the matched text. Use :s for current line only."]], "query": "vim search replace"}
{"output": [["lex", "http status codes list"], ["lex", "http 200 400 500 codes"], ["lex", "rest api status codes"], ["vec", "what do the common http status codes mean and when should you use each"], ["vec", "how do you choose the right http status code for api responses"], ["hyde", "200 OK success, 201 Created for POST, 204 No Content for DELETE. 400 Bad Request for invalid input, 401 Unauthorized for auth required, 403 Forbidden for insufficient permissions, 404 Not Found. 500 Internal Server Error for unexpected failures, 503 Service Unavailable for temporary issues."]], "query": "http status codes meaning"}
{"output": [["lex", "docker environment variables"], ["lex", "docker env file compose"], ["lex", "docker run -e env vars"], ["vec", "how to pass environment variables to docker containers"], ["vec", "what are the different ways to set environment variables in docker and docker compose"], ["hyde", "Use -e flag: docker run -e DB_HOST=localhost myapp. In docker-compose.yml: environment: - DB_HOST=localhost or env_file: - .env. For secrets, prefer docker secrets or mount files. Variables in Dockerfile with ENV persist in the image; runtime -e overrides them."]], "query": "environment variables docker"}
{"output": [["lex", "rate limiting algorithm api"], ["lex", "token bucket leaky bucket"], ["lex", "rate limit sliding window"], ["vec", "what algorithms are used for api rate limiting and how do they differ"], ["vec", "how do token bucket and sliding window rate limiting algorithms work"], ["hyde", "Token bucket: bucket fills at fixed rate, requests consume tokens, rejected when empty—allows bursts. Leaky bucket: requests queue, processed at fixed rate—smooths traffic. Sliding window: count requests in rolling time window. Fixed window has boundary issues; sliding window log is precise but memory-heavy."]], "query": "rate limiting algorithms"}
{"output": [["lex", "memory leak debug profiler"], ["lex", "memory leak detection tools"], ["lex", "heap dump memory analysis"], ["vec", "how to find and fix memory leaks in applications"], ["vec", "what tools and techniques help identify memory leaks in different programming languages"], ["hyde", "Use heap profilers: Chrome DevTools for JavaScript, VisualVM or MAT for Java, Valgrind for C/C++, tracemalloc for Python. Take heap snapshots before and after operations, compare retained objects. Common causes: forgotten event listeners, closures holding references, unbounded caches, circular references."]], "query": "memory leak debugging"}
{"output": [["lex", "stripe webhook signature verify"], ["lex", "stripe webhook endpoint secret"], ["lex", "stripe event verification"], ["vec", "how to verify stripe webhook signatures to ensure events are authentic"], ["vec", "what is the correct way to handle and validate incoming stripe webhook events"], ["hyde", "Stripe signs webhooks with your endpoint secret. Verify using stripe.webhooks.constructEvent(body, sig, endpointSecret). Use the raw request body, not parsed JSON. Return 200 quickly, process async. Handle event types like checkout.session.completed. Store endpoint secret securely, rotate if compromised."]], "query": "Stripe webhook verification"}
{"output": [["lex", "react context redux comparison"], ["lex", "useContext vs redux state"], ["lex", "react state management choice"], ["vec", "when should you use react context versus redux for state management"], ["vec", "what are the tradeoffs between react context api and redux for global state"], ["hyde", "Context is built-in, simple for low-frequency updates like themes and auth. Redux adds boilerplate but provides devtools, middleware, time-travel debugging, predictable updates. Context re-renders all consumers on any change; Redux allows granular subscriptions. Use Context for simple cases, Redux for complex state logic."]], "query": "React context vs Redux"}
{"output": [["lex", "dns records types a cname mx"], ["lex", "dns configuration records"], ["lex", "domain name system records"], ["vec", "what are the different types of dns records and what does each one do"], ["vec", "how do you configure dns records for a domain including a, cname, mx, and txt records"], ["hyde", "A record maps domain to IPv4 address. AAAA for IPv6. CNAME aliases one domain to another (can't be on root domain). MX for mail servers with priority. TXT for verification and SPF/DKIM. NS delegates to nameservers. TTL controls caching duration. Changes propagate based on previous TTL."]], "query": "DNS records explained"}
{"output": [["lex", "tmux session window pane"], ["lex", "tmux attach detach session"], ["lex", "tmux commands shortcuts"], ["vec", "how to create and manage tmux sessions for persistent terminal workflows"], ["vec", "what are the essential tmux commands for session, window, and pane management"], ["hyde", "Start session: tmux new -s name. Detach: Ctrl-b d. Reattach: tmux attach -t name. New window: Ctrl-b c. Split pane: Ctrl-b % (vertical), Ctrl-b \" (horizontal). Navigate panes: Ctrl-b arrow. List sessions: tmux ls. Kill session: tmux kill-session -t name. Sessions persist after disconnect."]], "query": "tmux session management"}
{"output": [["lex", "utf-8 unicode encoding"], ["lex", "utf8 character encoding bytes"], ["lex", "unicode utf-8 ascii difference"], ["vec", "how does utf-8 encoding work and why is it the standard for text"], ["vec", "what is the relationship between unicode and utf-8 and how are characters encoded as bytes"], ["hyde", "UTF-8 encodes Unicode code points as 1-4 bytes. ASCII characters (0-127) use 1 byte, compatible with ASCII. Higher code points use more bytes with leading bits indicating length. UTF-8 is self-synchronizing and space-efficient for Latin text. Always specify encoding explicitly when reading/writing files."]], "query": "utf-8 encoding explained"}
{"output": [["lex", "bash script best practices"], ["lex", "shell script error handling"], ["lex", "bash scripting guidelines"], ["vec", "what are the best practices for writing reliable and maintainable shell scripts"], ["vec", "how do you handle errors and edge cases properly in bash scripts"], ["hyde", "Start with #!/usr/bin/env bash and set -euo pipefail. Use shellcheck for linting. Quote variables: \"$var\". Use [[ ]] for tests. Handle errors with trap. Use functions for reusability. Avoid parsing ls output—use globs. Prefer printf over echo. Use local variables in functions. Add -- before filenames from user input."]], "query": "shell script best practices"}
{"output": [["lex", "load balancer health check"], ["lex", "health check endpoint liveness"], ["lex", "lb health probe configuration"], ["vec", "how do load balancer health checks work and why are they important"], ["vec", "what should a health check endpoint return and how do you configure health check intervals"], ["hyde", "Load balancers probe backend instances to route traffic only to healthy ones. Health endpoint should check critical dependencies (database, cache) and return 200 if healthy, 503 if not. Configure interval (10-30s), timeout (5s), and threshold (2-3 failures). Include /health and /ready endpoints for Kubernetes liveness and readiness."]], "query": "load balancer health checks"}
{"output": [["lex", "ssl tls certificate renewal"], ["lex", "lets encrypt certbot renew"], ["lex", "https certificate expiration"], ["vec", "how to renew ssl tls certificates before they expire"], ["vec", "what is the process for automated certificate renewal with lets encrypt and certbot"], ["hyde", "Let's Encrypt certificates expire in 90 days. Certbot auto-renews via cron or systemd timer: certbot renew runs twice daily, renews within 30 days of expiry. Test with --dry-run. For other CAs, set calendar reminders. Check expiration: openssl s_client -connect domain:443 | openssl x509 -noout -dates."]], "query": "certificate ssl tls renewal"}
{"output": [["lex", "python decorator function"], ["lex", "python @ decorator syntax"], ["lex", "python wrapper decorator"], ["vec", "how do python decorators work and what is the syntax for creating them"], ["vec", "what are common use cases for decorators in python like logging, caching, and authentication"], ["hyde", "Decorators wrap functions to extend behavior. @decorator before def is syntactic sugar for func = decorator(func). A decorator is a function taking a function and returning a new function. Use functools.wraps to preserve metadata. Common uses: @lru_cache for memoization, @login_required for auth, timing/logging wrappers."]], "query": "python decorators explained"}
{"output": [["lex", "cap theorem distributed database"], ["lex", "consistency availability partition tolerance"], ["lex", "cap theorem tradeoffs"], ["vec", "what is the cap theorem and how does it apply to distributed database design"], ["vec", "how do different databases choose between consistency and availability during network partitions"], ["hyde", "CAP theorem: distributed systems can guarantee only 2 of 3—Consistency (all nodes see same data), Availability (requests get responses), Partition tolerance (survives network splits). During partitions, choose CP (reject requests for consistency, like MongoDB) or AP (serve potentially stale data, like Cassandra). PACELC extends CAP for normal operation tradeoffs."]], "query": "cap theorem database"}
{"output": [["lex", "garbage collection gc tuning"], ["lex", "jvm gc heap memory"], ["lex", "gc pause time optimization"], ["vec", "how to tune garbage collection for better application performance"], ["vec", "what gc algorithms are available and how do you choose gc settings for low latency"], ["hyde", "For JVM, G1GC is default, good balance of throughput and pause times. ZGC and Shenandoah offer sub-millisecond pauses for low-latency needs. Tune heap size: -Xms and -Xmx same to avoid resizing. Monitor with gc logs: -Xlog:gc*. Reduce allocation rate by reusing objects and avoiding unnecessary autoboxing."]], "query": "garbage collection tuning"}
{"output": [["lex", "feature flags toggles"], ["lex", "feature flag implementation"], ["lex", "gradual rollout feature flags"], ["vec", "how to implement feature flags for gradual rollouts and a/b testing"], ["vec", "what are the best practices for managing feature flags in production"], ["hyde", "Feature flags decouple deployment from release. Simple: if (featureEnabled('new-checkout')) { ... }. Store flags in config, database, or services like LaunchDarkly. Use for gradual rollout (1% -> 10% -> 100%), A/B tests, kill switches. Clean up old flags to prevent technical debt. Log flag evaluations for debugging."]], "query": "feature flags implementation"}
{"output": [["lex", "kafka partitions topics"], ["lex", "kafka partition key ordering"], ["lex", "kafka partition count scaling"], ["vec", "how do kafka partitions work and how do they affect scalability and message ordering"], ["vec", "how do you choose the right number of partitions for a kafka topic"], ["hyde", "Partitions enable parallelism—each partition is consumed by one consumer in a group. Messages with same key go to same partition, preserving order per key. More partitions = more throughput but more overhead. Start with partitions = max(expected throughput / partition throughput, consumer count). Can't reduce partitions, only increase."]], "query": "apache kafka partitions"}
{"output": [["lex", "gpg key sign verify"], ["lex", "gpg signature git commits"], ["lex", "pgp key signing encryption"], ["vec", "how to use gpg keys for signing and verifying files and git commits"], ["vec", "what is the process for creating gpg keys and configuring git to sign commits"], ["hyde", "Generate key: gpg --full-generate-key. List keys: gpg --list-keys. Sign file: gpg --sign file.txt. Verify: gpg --verify file.txt.gpg. For git: git config --global user.signingkey KEYID, git config --global commit.gpgsign true. Export public key for GitHub: gpg --armor --export KEYID."]], "query": "GPG key signing"}
{"output": [["lex", "api versioning strategy"], ["lex", "rest api version url header"], ["lex", "api backward compatibility"], ["vec", "what are the different strategies for versioning rest apis"], ["vec", "how do you maintain backward compatibility when evolving an api"], ["hyde", "URL versioning (/v1/users) is explicit, easy to route. Header versioning (Accept: application/vnd.api+json;version=1) keeps URLs clean. Query param (?version=1) is simple but pollutes URLs. Prefer additive changes—new fields don't break clients. Deprecate gracefully with sunset headers and migration guides."]], "query": "api versioning strategies"}
{"output": [["lex", "mutex semaphore difference"], ["lex", "mutex lock synchronization"], ["lex", "semaphore counting binary"], ["vec", "what is the difference between a mutex and a semaphore in concurrent programming"], ["vec", "when should you use a mutex versus a semaphore for thread synchronization"], ["hyde", "Mutex is a binary lock owned by one thread—used for mutual exclusion protecting shared resources. Semaphore is a counter allowing N concurrent accesses—used for limiting concurrency (connection pools, rate limiting). Mutex has ownership (same thread must unlock), semaphore doesn't. Use mutex for critical sections, semaphore for resource counting."]], "query": "mutex vs semaphore"}
{"output": [["lex", "ipv4 ipv6 difference"], ["lex", "ipv6 address format"], ["lex", "ipv4 exhaustion ipv6 transition"], ["vec", "what are the key differences between ipv4 and ipv6 addressing"], ["vec", "why is ipv6 necessary and how does the transition from ipv4 work"], ["hyde", "IPv4 uses 32-bit addresses (4 billion), exhausted in 2011. IPv6 uses 128-bit addresses (340 undecillion), formatted as eight hex groups: 2001:0db8::1. IPv6 eliminates NAT need, has built-in IPsec. Transition via dual-stack (both protocols) or tunneling. Check IPv6 support: curl -6 ipv6.google.com."]], "query": "IPv4 vs IPv6"}
{"output": [["lex", "dependency injection di pattern"], ["lex", "di inversion of control ioc"], ["lex", "dependency injection testing"], ["vec", "what is dependency injection and why does it improve code maintainability"], ["vec", "how does dependency injection make unit testing easier"], ["hyde", "Dependency injection provides dependencies from outside rather than creating them internally. Class receives DatabaseService via constructor instead of instantiating it. Benefits: loose coupling, easy testing with mocks, flexible configuration. Instead of new EmailService(), inject interface IEmailService—swap implementations without changing consumer code."]], "query": "dependency injection benefits"}
{"output": [["lex", "s3 bucket policy permissions"], ["lex", "aws s3 iam policy json"], ["lex", "s3 bucket access control"], ["vec", "how to write an s3 bucket policy to control access permissions"], ["vec", "what is the difference between s3 bucket policies and iam policies for access control"], ["hyde", "S3 bucket policies are resource-based JSON policies attached to buckets. Grant public read: {\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":\"*\",\"Action\":\"s3:GetObject\",\"Resource\":\"arn:aws:s3:::bucket/*\"}]}. IAM policies attach to users/roles. Use bucket policies for cross-account access, IAM for user-specific permissions. Block public access settings override policies."]], "query": "S3 bucket policy"}
{"output": [["lex", "database sharding horizontal"], ["lex", "shard key partition strategy"], ["lex", "database horizontal scaling"], ["vec", "what is database sharding and what strategies exist for partitioning data"], ["vec", "how do you choose a shard key and what are the tradeoffs of different sharding approaches"], ["hyde", "Sharding distributes data across multiple databases. Strategies: range-based (user IDs 1-1M on shard 1), hash-based (consistent hashing), directory-based (lookup table). Choose shard key with high cardinality, even distribution, query locality. Avoid hot spots—don't shard by timestamp. Cross-shard queries are expensive. Consider sharding only after vertical scaling exhausted."]], "query": "database sharding strategies"}
{"output": [["lex", "compile time runtime error difference"], ["lex", "static dynamic type checking"], ["lex", "compilation errors vs exceptions"], ["vec", "what is the difference between compile time and runtime errors in programming"], ["vec", "why are compile time errors generally preferable to runtime errors for code reliability"], ["hyde", "Compile time errors occur during compilation before code runs—syntax errors, type mismatches in statically typed languages. Runtime errors occur during execution—null pointer, division by zero, file not found. Compile time errors are caught early, cheaper to fix. Static typing and linters catch more at compile time. TypeScript catches errors that JavaScript defers to runtime."]], "query": "compile time vs runtime errors"}
{"output": [["lex", "cdn content delivery network"], ["lex", "cdn caching edge servers"], ["lex", "cloudflare cdn setup"], ["vec", "how does a content delivery network cdn improve website performance"], ["vec", "what content should you serve through a cdn and how do you configure cache headers"], ["hyde", "CDN caches content at edge servers geographically close to users, reducing latency. Serve static assets (images, CSS, JS) through CDN. Set Cache-Control headers: max-age=31536000 for versioned assets, shorter for dynamic content. Configure origin pulls, purge cache on deploys. Popular CDNs: Cloudflare, CloudFront, Fastly, Akamai."]], "query": "content delivery network cdn"}
{"output": [["lex", "mac address ip address difference"], ["lex", "mac address layer 2 hardware"], ["lex", "ip vs mac network address"], ["vec", "what is the difference between a mac address and an ip address in networking"], ["vec", "how do mac addresses and ip addresses work together for network communication"], ["hyde", "MAC address is hardware identifier burned into NIC, 48 bits (AA:BB:CC:DD:EE:FF), used in Layer 2 (local network). IP address is logical, assigned by network, used in Layer 3 (routing). ARP maps IP to MAC on local network. IP gets packets between networks, MAC delivers within a network segment. MAC is permanent, IP changes with network."]], "query": "mac address vs ip address"}
{"output": [["lex", "unit test integration test difference"], ["lex", "testing pyramid unit integration e2e"], ["lex", "unit test isolation mocking"], ["vec", "what is the difference between unit tests and integration tests"], ["vec", "how should you balance unit tests and integration tests in the testing pyramid"], ["hyde", "Unit tests verify single functions or classes in isolation using mocks for dependencies. Fast, many of them. Integration tests verify components working together with real dependencies. Slower, fewer of them. Testing pyramid: many unit tests at base, fewer integration tests in middle, few e2e tests at top. Unit tests catch logic bugs, integration tests catch interface mismatches."]], "query": "unit test vs integration test"}
{"output": [["lex", "webhook vs polling api"], ["lex", "push vs pull api pattern"], ["lex", "webhook callback http"], ["vec", "what are the differences between webhooks and api polling for receiving updates"], ["vec", "when should you use webhooks instead of polling an api for changes"], ["hyde", "Polling: client repeatedly asks server for updates. Simple but wastes bandwidth if nothing changed, may miss events between polls. Webhooks: server pushes updates to client endpoint when events occur. Real-time, efficient, but requires public endpoint and handling failures. Use webhooks when available (Stripe, GitHub), fall back to polling for systems without webhook support."]], "query": "webhook vs api polling"}
{"output": [["lex", "yaml json config comparison"], ["lex", "yaml vs json syntax"], ["lex", "configuration file format"], ["vec", "what are the differences between yaml and json for configuration files"], ["vec", "when should you choose yaml over json for application configuration"], ["hyde", "JSON: strict syntax, no comments, explicit quotes, universal parsing. YAML: superset of JSON, allows comments, cleaner for humans, indentation-based. Use JSON for data interchange, APIs, when strict parsing needed. Use YAML for configs (Docker Compose, Kubernetes, CI/CD) where human editing is common. YAML gotchas: Norway problem (NO parsed as false), inconsistent indentation."]], "query": "yaml vs json config"}
{"output": [["lex", "solid principles oop"], ["lex", "single responsibility open closed"], ["lex", "solid design principles"], ["vec", "what are the solid principles in object oriented design"], ["vec", "how do the solid principles improve code maintainability and flexibility"], ["hyde", "SOLID: Single Responsibility (one reason to change), Open/Closed (open for extension, closed for modification), Liskov Substitution (subtypes substitutable for base types), Interface Segregation (many specific interfaces over one general), Dependency Inversion (depend on abstractions not concretions). Following SOLID produces loosely coupled, testable, maintainable code."]], "query": "solid principles explained"}
{"output": [["lex", "protobuf json comparison"], ["lex", "protocol buffers serialization"], ["lex", "grpc protobuf format"], ["vec", "what are the differences between protocol buffers and json for data serialization"], ["vec", "when should you use protobuf instead of json for api communication"], ["hyde", "JSON: human-readable, self-describing, universal support, larger payload. Protobuf: binary format, 3-10x smaller, faster serialization, requires schema (.proto files), strong typing. Use JSON for public APIs, debugging, human interaction. Use Protobuf for internal microservices, high-throughput systems, gRPC. Schema evolution with field numbers enables backward compatibility."]], "query": "protobuf vs json"}
{"output": [["lex", "stateless stateful service"], ["lex", "stateless api design"], ["lex", "session state storage"], ["vec", "what is the difference between stateless and stateful services in application architecture"], ["vec", "why are stateless services easier to scale and how do you handle state when needed"], ["hyde", "Stateless services don't store client state between requests—any instance can handle any request. Scale by adding instances, no session affinity needed. Stateful services maintain client state, requiring sticky sessions or shared storage. Make services stateless by storing session in JWT tokens, Redis, or databases. Stateless is preferred for horizontal scaling and resilience."]], "query": "stateless vs stateful services"}
{"output": [["lex", "git bisect bug finding"], ["lex", "git bisect good bad"], ["lex", "binary search git commit"], ["vec", "how to use git bisect to find the commit that introduced a bug"], ["vec", "what is the git bisect workflow for binary search debugging through commit history"], ["hyde", "git bisect does binary search through commits to find where bug was introduced. Start: git bisect start, git bisect bad (current has bug), git bisect good v1.0 (known good commit). Git checks out middle commit—test and mark git bisect good or git bisect bad. Repeat until found. Automate with git bisect run ./test.sh. End with git bisect reset."]], "query": "git bisect debugging"}
{"output": [["lex", "roman empire fall causes"], ["lex", "decline of rome 476 AD"], ["lex", "western roman empire collapse"], ["vec", "what were the main causes of the fall of the western roman empire"], ["vec", "how did economic, military, and political factors contribute to rome's collapse"], ["hyde", "The Western Roman Empire fell in 476 AD when Odoacer deposed Romulus Augustulus. Contributing factors included economic troubles, military overextension, political instability with rapid emperor turnover, pressure from Germanic tribes, and the division of the empire. The Eastern Roman Empire (Byzantine) survived until 1453."]], "query": "fall of the Roman Empire"}
{"output": [["lex", "world war 1 causes"], ["lex", "ww1 assassination archduke franz ferdinand"], ["lex", "causes great war 1914"], ["vec", "what were the main causes and triggers of world war one"], ["vec", "how did the assassination of archduke franz ferdinand lead to a global war"], ["hyde", "WWI was caused by MAIN: Militarism, Alliances, Imperialism, Nationalism. The assassination of Archduke Franz Ferdinand on June 28, 1914 in Sarajevo triggered a chain reaction through alliance systems. Austria-Hungary declared war on Serbia, pulling in Russia, Germany, France, and Britain within weeks."]], "query": "causes of World War I"}
{"output": [["lex", "egyptian pyramids how built"], ["lex", "pyramid construction ancient egypt"], ["lex", "great pyramid giza building"], ["vec", "how were the ancient egyptian pyramids constructed without modern technology"], ["vec", "what techniques and labor did ancient egyptians use to build the pyramids at giza"], ["hyde", "The pyramids were built using ramps, levers, and organized labor forces of tens of thousands of workers. Limestone blocks weighing 2.5 tons average were quarried nearby and transported on sledges. Workers were not slaves but paid laborers housed in nearby villages. The Great Pyramid took approximately 20 years to complete around 2560 BC."]], "query": "ancient Egypt pyramids construction"}
{"output": [["lex", "protestant reformation luther"], ["lex", "martin luther 95 theses"], ["lex", "reformation 1517 catholic church"], ["vec", "what started the protestant reformation and what were its main ideas"], ["vec", "how did martin luther's 95 theses challenge the catholic church and spread across europe"], ["hyde", "Martin Luther posted his 95 Theses on October 31, 1517 in Wittenberg, criticizing indulgences and papal authority. Key ideas: salvation by faith alone, scripture as sole authority, priesthood of all believers. The printing press spread his ideas rapidly. Luther was excommunicated in 1521. The Reformation split Western Christianity and sparked religious wars across Europe."]], "query": "Protestant Reformation Martin Luther"}
{"output": [["lex", "silk road trade route"], ["lex", "silk road ancient trade china"], ["lex", "silk road history commerce"], ["vec", "what was the silk road and how did it connect east and west"], ["vec", "what goods and ideas were exchanged along the ancient silk road trade routes"], ["hyde", "The Silk Road was a network of trade routes connecting China to the Mediterranean from around 130 BC to 1450s AD. Goods traded: silk, spices, porcelain from East; gold, glass, horses from West. Also spread Buddhism, Islam, technologies like paper and gunpowder, and unfortunately, the Black Death. Named by German geographer Ferdinand von Richthofen in 1877."]], "query": "Silk Road trade routes"}
{"output": [["lex", "world war 2 d-day normandy"], ["lex", "d-day june 6 1944 invasion"], ["lex", "operation overlord ww2"], ["vec", "what happened on d-day and why was the normandy invasion a turning point in world war two"], ["vec", "how was the d-day invasion of normandy planned and executed by allied forces"], ["hyde", "D-Day, June 6, 1944, was the largest amphibious invasion in history. Operation Overlord landed 156,000 Allied troops on five Normandy beaches (Utah, Omaha, Gold, Juno, Sword). Despite 10,000+ casualties, it established a Western Front, leading to Paris liberation (August 1944) and Germany's surrender (May 1945). Supreme Commander: Dwight D. Eisenhower."]], "query": "World War II D-Day"}
